<!doctype html>
<html>

<head>
  <title>drumweb</title>
  <meta charset="utf-8">
</head>

<body>
  <h1><a href="index.html">Drum</a></h1>
  <ol>
    <li><a href="1.html">drummer</a></li>
    <li><a href="2.html">kit</a></li>
    <li><a href="3.html">kind</a></li>
    <li><a href="4.html">random practice</a></li>
  </ol>
  <ul>
    <li><a href="dailynote.html">dailynote</a></li>
    <li>I like drum!</li>
  </ul>
  <blockquote>
    <h2>
      <hr>
      <hr>12/27</h2>
    <hr>
    <hr>

    <p>생활코딩 강의중 Web1을 완강했다.<br>Html이란 무엇인가. 웹과 인터넷. 클라이언트와 서버.
      웹서버 운영. 코드의 힘 등을 배웠고 실제로 드럼 웹사이트를 약간 만들어보았다.<br>
      홈페이지에는 드러머, 드럼킷, 랜덤 연습생성, 매일 공부노트의 목차를 구성했고 구체적인 내용은
      아직 정하지 않았다.<br> 이곳에 댓글, 채팅, 웹사이트 분석의 코드는 전문 홈페이지에서 따왔고
      유투브 동영상 삽입, 이미지 삽입, 링크 삽입 들의 실습을 해보았다.<br> 다음은 Web2코스의 CSS를 해보겠다.
    </p>
  </blockquote>

  <blockquote>
    <h2>
      <hr>
      <hr>12/28</h2>
    <hr>
    <hr>

    <p>코딩 도장으로 C언어 복습을 시작했다. 대부분은 익숙한 내용이었기에 복습개념으로 빠르게 훓어봤다.<br>
      디버그 사용법은 처음 알았는데 먼저 중단점을 찍고 프로시저 단위 실행은 F10, 한 단계씩 코드 실행: F11로 처리를 하였다. good<br>
      이후에 정수형 변수 관련해서 공부했고 오버플로우 내용에서 "stdint.h" 와 "limit.h" 로 최대값 최소값을 표현하는 방법을 알게 되었다.<br>
      다음은 실수형 변수 관련 공부를 하겠다.
    </p>
  </blockquote>

  <blockquote>
    <h2>
      <hr>
      <hr>12/30</h2>
    <hr>
    <hr>

    <p>CSS를 시작했다 CSS는 HTML의 디자인적인 부분을 보완하기 위해서 태어났다.<br>코드에 "style" 태그로 CSS 문법임을 표시한다. 내용에는 선택자와 서술부로 나뉘는데<br>
      효과적으로 선택하기 위한 여러가지 방법을 CSS Diner이라는 게임을 통해 공부했다.<br>pseudo 코드는 생활코딩 강의로만 알아봤는데 사용법이 다른 것과는 달랐다.<br>
      다음은 서술부에 해당하는 속성을 배우면 될 것 같다.
    </p>
  </blockquote>

  <blockquote>
    <h2>
      <hr>
      <hr>1/03</h2>
    <hr>
    <hr>

    <p>코딩 도장 16강까지 완료했다. 자료형, 상수, 사칙연산, 자료형의 확장과 축소등을 공부했다. 실수에 관해서 부동소수점 표기와 사용법을 알게 되었다.<br>
      행렬 곱셈을 통한 아핀변환(affin transformation)은 3D엔진 게임에 많이 사용된다고 한다. 실수의 최소값 최대값은 "float.h"를 사용하면 편리했다.<br>
      상수는 const를 통해 선언하고 상수와 구분되는 리터럴에 관한 표기법 사용법 또한 알아 보았다. <br> 사칙연산중 실수의 나머지를 구할때는 "math.h"에서 fmod함수종류
      (fmodf, fmodl)를 사용하면 된다. 다음은 if조건문을 시작하게 된다.
    </p>
  </blockquote>

  <blockquote>
    <h2>
      <hr>
      <hr>1/23</h2>
    <hr>
    <hr>

    <p>오랜만에 공부를 다시 시작한다. CSS 서술부에 관련한 속성을 배웠으나 잘기억이 나지 않아서 웹프로그래밍은 그 부분부터 다시 공부하면 될 듯하다.<br>
      개발 아이디어로 랜덤으로 드럼 연습 루디먼트를 생성하는 프로그램을 생각했고 C언어로 구현해 보았다. 현재 86줄 짜리 코드로서 16비트 루디먼트만<br>
      표현 해낼수 있다. 이를 앱까지 만들어보고 싶은데 안드로이드 스튜디오 사용법과 인터페이스 구현을 익혀서 해야할 듯 하다.<br>이렇게 웹 프로그래밍, C언어,
      안드로이드 앱 3가지 분야를 해야한다는 생각을 현재 가지고 있다.
    </p>

    <p>C언어 코딩도장에서 if조건문, 비교연산자와 삼항연산자를 공부했다.
      조건문을 쓸때 유의할 점을 찾았는데 'n이 a보다크고 b보다 작다' 라는 조건을 걸때는 a < n < b가 아니라 n> a && n > b 으로 써야 한다는점이다.<br>
        삼항연산자는 num1 == 10 ? 100 : 200; 으로 사용하고 num1 == 10이 참이면 100, 거짓이면 200을 선택한다.<br> 다음은 논리연산자부터 시작
    </p>
  </blockquote>

  <blockquote>
    <h2>
      <hr>
      <hr>1/26</h2>
    <hr>
    <hr>

    <p>불연산자의 자료형을 사용하기 위해서는 "stdbool.h"를 사용해야 한다. true, false, bool 등을 사용할 수 있다. ex) bool b1 = true; //선언<br>
      비트연산 또한 사용가능하다.시프트 연산은 2의 거듭제곱 곱하기 또는 나누기를 표현 할수있다.<br><img src="images/c/c언어 비트연산자.png" width="15%"><br>
      비트연산자로 플래그를 처리하는 방법이 있다. 특정비트를 켜는 방법은 flag |= 마스크, 끄는 방법은 flag &= ~마스크, 토글하는 방법은 flag ^= 마스크이다.<br>
      (플래그의 비트를 조작하거나 검사할때 사용하는 숫자를 '마스크' 라고 부른다) <br>ex) unsigned char flag = 1 << 3 // 0000 0100<br>
        flag |= 1 << 6 // 0100 0100<br>
          flag ^= 1 << 7 // 1100 0100<br><img src="images/c/플래그 연산방법.png" width="25%"><br>
            다음은 switch분기문을 시작한다. 진도가 너무 늦는듯하네. 웹공부는 CSS끝나고 Python을 들으면 될듯하다. 그렇게 길지않음.
    </p>

    <p>c언어로 안드로이드 앱을 개발할 수 있는 방법에 NDK를 사용하는 방법이 있다.
    </p>
  </blockquote>

  <blockquote>
    <h2>
      <hr>
      <hr>1/28</h2>
    <hr>
    <hr>

    <p>switch분기에서 break를 생략함으로서 '또는'과 같은 효과를 낼 수 있다. break로 중단시키지 않은 case는 다음 case까지 실행 시키기 떄문.<br>switch분기문에서
      변수를 선언하려면 case를 중괄호로 묶어야 한다.<br>for 반복문은 반복 횟수가 정해져있을때 유용하고 while 반복문은 반복 횟수가 정해져있지 않을때 유용하다.<br>
      다음 그림은 for반복문에서 2개의 변수를 사용하는 예이다.<br>
      <img src="images/c/for 변수두개 예시.png" width="40%"><br>
    </p>

  </blockquote>

  <blockquote>
    <h2>
      <hr>
      <hr>1/29~1/30</h2>
    <hr>
    <hr>

    <p>반복문에서 continue, break에 대해 알아보았고, 심사문제로 산모양으로 별을 출력하는 프로그램을 작성했다.<br>산 모양의 별은 출력하는 프로그램을 작성할 때는
      이중루프를 썻고 안쪽의 반복문에서는 높이에 따라 변하는 변수가 하나더 필요했다.<br><img src="images/c/산모양 별출력.png" width="20%"><br><br>
      반복문을 돌려 원하는 결과를 얻을 때 핵심은 각 실행단계에서 영향을 주는 변수를 파악하는 것이라 느꼇다.<br><br> goto문으로 코드를 작성하는 방법을 배웠고,
      FizzBuzz 프로그래밍을 작성했다.(최대공약수 문제)
    </p>

    <p>포인터 시작.<br><img src="images/c/포인터.png" width="40%"><br><br>
      <br>
      <hr>
      메모리의 내용을 디버거에서 직접 확인하는 방법으로 메뉴의 디버그(D) > 창(W) > 메모리(M) > 메모리 1(1)을 클릭하면 메모리 탭이 열리고 주소를 넣으면 주소안의 값을 볼 수 있다.
      <br><br>const로도 포인터형 변수를 선언 할 수 있는데 이때는 포인터형 변수가 가리키는 주소를 변경할 수 없다. 또한 const로 선언한 변수는 포인터형 변수로 역참조할 수 없다.<br>
      <br>
      <hr>
      void 포인터는 자료형이 정해지지 않은 특성 때문에 어떤 자료형으로 된 포인터든 모두 저장할 수 있다.<br>
      단, void 포인터는 자료형이 정해지지 않았으므로 값을 가져오거나 저장할 크기도 정해지지 않았다. 따라서 void 포인터는 역참조를 할 수 없다.<br>
      void 포인터 변수는 함수의 반환 포인터를 다양한 자료형으로 된 포인터에 저장할 때, 자료형을 숨기고 싶을 때 사용한다고 한다.<br><br>
      <br>
      <hr>
      포인터도 실제로 변수이기 때문에 메모리 주소를 구할 수 있지만 포인터의 메모리 주소는 일반 포인터에 저장할 수 없고, int **numPtr2;처럼 이중 포인터에 저장해야 한다.<br>
      int *numPtr1;<br>
      int **numPtr2;<br>
      numPtr2 = &numPtr1; // numPtr1의 메모리 주소 저장<br>

      <p>메모리 사용 패턴<br><img src="images/c/메모리사용.png" width="15%"><br><br>
        <br>
        <hr>
        malloc 함수를 사용하여 힙에서 할당한 메모리는 반드시 해제를 해주어야 한다.<br>
        numPtr2 = malloc(sizeof(int));<br>
        ...<br>
        free(numPtr2);<br>
        <br>
        <hr>
        memset 함수를 사용하면 메모리의 내용을 원하는 크기만큼 특정값으로 설정할 수 있다<br>
        ex) memset(numPtr, 0x27, 8); // numPtr이 가리키는 메모리를 8바이트만큼 0x27로 설정한다.<br><br>
        <br>
        <hr>
        NULL이 들어있는 포인터를 널 포인터(null pointer)라고 하며 아무것도 가리키지 않는 상태를 뜻한다. 따라서 역참조는 할 수 없다.<br>
      </p>
  </blockquote>

  <blockquote>
    <h2>
      <hr>
      <hr>1/31</h2>
    <hr>
    <hr>

    <p>
      <h3>배열시작</h3> 이미 선언된 배열의 크기를 구하려면 sizeof(배열이름), 배열의 요소개수를 구할 때는 sizeof(배열이름)/sizeof(자료형크기)로 하면된다.<br>
      <br>
      <hr>
      이차원 배열에서 세로(row, 열)의 요소 개수는 배열이 차지하는 전체 공간을 가로 한 줄의 크기로 나눠주면 되고,<br>
      가로(column, 행)의 요소 개수를 구하려면 sizeof(numArr[0])와 같이 가로 한 줄의 크기를 구한 뒤 요소의 크기로 나누면 된다.<br><br>
      2차원 배열을 포인터에 담으려면 다음과 같이 특별한 방법이 필요합니다.<br>
      -> 자료형 (*포인터이름)[가로크기];<br>
      즉, 포인터를 선언할 때 *과 포인터 이름을 괄호로 묶어준 뒤 [ ]에 가로 크기를 지정합니다.int (*numPtr)[4];
      <br><img src="images/c/2차원배열과 포인터.png" width="40%"><br><br>
      <br>
      <hr>
      다음은 38.0 포인터와 배열응용 을 한다.
    </p>

  </blockquote>

  <blockquote>
    <h2>
      <hr>
      <hr>2/4</h2>
    <hr>
    <hr>

    <p>입력한 크기만큼 배열을 할당하여 사용하는법 -> int *numPtr = malloc(sizeof(int) * size); // size = 입력받은 크기<br>
      <br>
      <hr>
      <br>int **m = malloc(sizeof(int *) * 3); // 이중 포인터에 (int 포인터 크기 * 세로 크기)만큼 메모리 할당. 배열의 세로<br><br>
      for (int i = 0; i < 3; i++) // 세로 크기만큼 반복<br>
        {<br>
        &nbsp;&nbsp;&nbsp;m[i] = malloc(sizeof(int) * 4); // (int 크기 * 가로 크기)만큼 동적 메모리 할당.<br>
        // 배열의 가로<br>
        }<br><br>
        <img src="images/c/2중포인터와 2차원배열.png" width="40%"><br><br>
        동적할당으로 배열크기만큼 변수에 할당시키면 인덱스 값으로 접근이 가능하다. 이는 이중포인터에 동적할당을 해도 마찬가지며 각각의 인덱스는 동적할당을 할 수 있다.<br>
        각각의 인덱스에 동적할당을 하면 이차원배열의 인덱스 값으로 접근이 가능하다.<br><br>
        메모리 해제는 가로->세로 순으로 한다.<br>
        for (int i = 0; i < row; i++) // 세로 크기만큼 반복<br>
          {<br>
          &nbsp;&nbsp;&nbsp;free(m[i]); // 2차원 배열의 가로 공간 메모리 해제<br>
          }<br>
          <br>
          free(m); // 2차원 배열의 세로 공간 메모리 해제<br>

          <br>
          <hr>2/04 지뢰찾기예제<br><br>
          <img src="images/c/지뢰찾기.png" width="30%"><br><br>
    </p>

  </blockquote>

  <blockquote>
    <h2>
      <hr>
      <hr>2/08</h2>
    <hr>
    <hr>

    <p>문자열을 사용할 때는 char 포인터에 " "(큰따옴표)로 묶은 문자열만 할당하면 된다. // char *s1 = "Hello";<br>
      단, 이 문자열 리터럴이 있는 메모리 주소는 읽기 전용이므로 다른 문자열을 덮어쓸 수는 없다.<br>*****C 언어의 문자열은 마지막에 항상 널 문자(NULL)가 붙는다.*****<br>

      <br>
      <hr><br>
      문자열은 문자(char) 배열에 저장할 수도 있다. // char 배열이름[크기] = "문자열";<br>
      배열로 문자열을 사용할 때 한 가지 주의할 점은 배열을 선언한 즉시 문자열로 초기화해야 한다는 점이다. 배열을 미리 선언해놓고 문자열을 나중에 할당할 수는 없다.<br>
      정 할당하고 싶다면 배열의 요소에 문자를 하나 하나 집어어야 한다.

      <br>
      <hr><br>
      scanf 함수에서 서식 지정자로 %s를 사용하면 입력 값을 배열 형태의 문자열에 저장할 수 있다.<br>
      scanf 함수에서 서식 지정자를 "%[^\n]s"와 같이 지정하면 공백까지 포함하여 문자열을 입력받을 수 있다. // scanf("%[^\n]s", s1);<br><br>

      char *s1 = "Hello";와 같이 문자열 포인터를 선언한 뒤 scanf 함수로 입력 값을 문자열 포인터에 저장했다. 얼핏 보면 저장이 될 것 같지만 실행을 해보면 에러가 발생한다.<br>
      왜냐하면 s1에 저장된 메모리 주소는 읽기만 할 수 있고, 쓰기가 막혀있기 때문이다. 따라서 s1과 같이 문자열 리터럴의 주소가 할당된 포인터는 scanf 함수에서 사용할 수 없다.<br><br>
      <img src="images/c/입력값을 문자형 포인터에 할당하는 잘못된 예.png" width="50%"><br><br>
      입력 값을 문자열 포인터에 저장하려면 문자열이 들어갈 공간을 따로 마련해야 된다. 따라서 다음과 같이 malloc 함수로 메모리를 할당한 뒤 문자열을 저장한다.<br>
      <img src="images/c/입력값을 문자형 포인터에 할당하는 올바른 예.png" width="50%"><br><br>

      <br>
      <hr><br>
      <h3>"string.h"파일</h3><br><br>
      *************strlen 함수로 문자열의 길이를 구할 수 있다. // strlen(문자열포인터); strlen(문자배열); <br><br>

      *************strcmp 함수로 두 문자열이 같은지 비교할 수 있다. // strcmp(문자열1, 문자열2);<blockquote>-1: ASCII 코드 기준으로 문자열2(s2)가 클 때<br>0: ASCII 코드 기준으로 두 문자열이 같을 때<br>1: ASCII 코드 기준으로 문자열1(s1)이 클 때</blockquote>

      <br><br>
      *************strcpy 함수로 문자열을 복사할 수 있다. // strcpy(대상문자열, 원본문자열);<br>
      문자열 포인터에 문자열을 복사하려면 문자열이 들어갈 공간을 따로 마련해야 된다. 따라서 다음과 같이 malloc 함수로 메모리를 할당한 뒤 문자열을 복사한다.<br>
      <img src="images/c/문자열 포인터에 문자열 복사.png" width="50%"><br><br>

      *************strcat 함수로 두 문자열을 연결할 수 있다. // strcat(최종문자열, 붙일문자열);<br><br>
      문자열 포인터에 문자열 붙이는 법<br>
      <img src="images/c/문자열 포인터에 문자열 붙이는법.png" width="50%"><br><br>

      *************strchr 함수로 문자열에서 특정 문자로 검색할 수 있다. // strchr(대상문자열, 검색할문자);<br>
      문자를 찾았으면 문자로 시작하는 문자열의 포인터를 반환, 문자가 없으면 NULL을 반환한다.<br>
      <img src="images/c/strchr 함수의 사용.png" width="50%"><br><br>
      문자열의 끝에서부터 문자를 검색하려면 strrchr 함수를 사용하면 된다. // strrchr(대상문자열, 검색할문자);<br><br>

      *************strstr 함수로 문자열에서 문자열 검색할 수 있다. // strstr(대상문자열, 검색할문자열);<br>
      문자열을 찾았으면 문자열로 시작하는 문자열의 포인터를 반환, 문자열이 없으면 NULL을 반환<br><br>
      <img src="images/c/strstr 함수의 사용.png" width="50%"><br><br>

      *************strtok 함수로 문자열을 자를 수 있다. // strtok(대상문자열, 기준문자);<br>
      자른 문자열을 반환, 더 이상 자를 문자열이 없으면 NULL을 반환한다.<br>
      문자열 포인터에 문자열 리터럴이 들어있어 읽기 전용인 상태라면 strtok 함수를 사용할 수 없다. // 문자열 포인터에 동적 메모리를 할당하고, 문자열을 복사하면 이 문제를 해결할 수 있다.<br>
      <br>자른 문자열 보관하기<br>
      <img src="images/c/자른 문자열 보관하기.png" width="50%"><br><br>

      <br>
      <hr>
      <br>
      <hr><br>
      sprintf 함수로 서식을 지정하여 문자열을 만들 수 있다. // sprintf(배열, 서식, 값); sprintf(배열, 서식, 값1, 값2, ...);<br>
      <img src="images/c/sprintf 함수의 사용.png" width="50%"><br><br>

      <br>
      <hr><br>
      문자열 자르기 심사문제를 하다 끊었다. 다음은 46. 문자열을 정수로 변환하기를 하겠다.<br>

  </blockquote>

  <blockquote>
    <h2>
      <hr>
      <hr>2/10</h2>
    <hr>
    <hr>

    <p>//특정 단어 개수 세기<br><br><img src="images/c/특정단어 개수세기 strtok().png" width="20%"><br><br>
      <br>
      <hr><br>
      *************atoi 함수로 문자열을 정수로 바꿀수 있다. // atoi(문자열); <br>
      atoi 함수에 문자열을 넣어주면 정수가 반환된다.<br>
      단, 문자열은 정수로 되어있어야 하며 알파벳 영문자, 특수 문자가 포함되면 해당 문자<u>부터는</u> 변환을 하지 않는다.<br>
      또한, 처음부터 숫자가 아니면 0으로 변환된다.<br>
      <br>
      <hr><br>
      *************strtol 함수로 16진법으로 표기된 문자열을 정수로 바꿀 수 있다. // strtol(문자열, 끝포인터, 진법);<br>
      strtol로 여러 개의 숫자로 된 문자열을 변환하기<br><br>
      <img src="images/c/strtol로 여러 개의 정수로 된 문자열을 변환하기.png" width="20%"><br><br>
      <br>
      <hr><br>
      *************atof 함수로 문자열을 실수로 바꿀수 있다. // atof(문자열);<br>
      atof 함수에 문자열을 넣어주면 실수가 반환된다.<br>
      단, 문자열은 실수로 되어있어야 하며 알파벳 영문자, 특수 문자가 포함되면 해당 문자부터는 변환을 하지 않는다.<br>
      또한, 처음부터 숫자가 아니면 0으로 변환된다.<br><br>
      <br>
      <hr><br>
      *************strtof 함수로 여러개의 실수로 된 문자열을 실수로 바꿀수 있다. // strtof(문자열, 끝포인터);<br>
      strtof로 여러개의 실수로 된 문자열을 변환하기<br><br>
      <img src="images/c/strtof로 여러개의 실수로 된 문자열을 변환하기.png" width="40%"><br><br>
      <br>
      <hr><br>
      *************sprintf 함수로 정수, 실수를 문자열로 바꿀수 있다. // sprintf(문자열, "%d", 정수); sprintf(문자열, "%f", 실수);<br>
      <br>
      <hr><br>
      // 공백을 포함한 회문 검사&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp// N-gram
      출력<br><br>
      <img src="images/c/공백을 포함한 회문 검사.png" width="20%">&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="images/c/N-gram 출력.png" width="30%"><br><br>
      <br>
      <hr><br>
      // 문자열 함수 요약<br><br>
      <img src="images/c/문자열 함수 요약.png" width="50%">
      <br>
      <hr><br>
      <h3>구조체 시작</h3><br><br>
      다른 자료형과 마찬가지로 구조체도 포인터를 선언할 수 있으며 구조체 포인터에는 malloc 함수를 사용하여 동적 메모리를 할당할 수 있다.<br>
      <blockquote>struct 구조체이름 *포인터이름 = malloc(sizeof(struct 구조체이름));</blockquote>

      typedef로 정의한 구조체 별칭으로도 포인터를 선언하고 메모리를 할당할 수 있다.
      <blockquote>구조체별칭 *포인터이름 = malloc(sizeof(구조체별칭));</blockquote>

      <u>구조체의 멤버가 포인터일 때 역참조를 하려면 맨 앞에 *를 붙이면 된다. 이때 구조체 변수 앞에 *가 붙어있더라도 멤버의 역참조이지 구조체 변수의 역참조가 아니다.</u><br><br>
    </p>
    <br>
    <hr>

    <p>문자열 자르기 심사문제를 풀었고 문자열과 정수를 서로 변환하는 함수들을 배웠다. 구조체를 시작했고 다음은 50. 구조체를이용해 두 점 사이의 거리 구하기를 하겠다.
    </p>

  </blockquote>

  <blockquote>
    <h2>
      <hr>
      <hr>2/13</h2>
    <hr>
    <hr>

    <p>
      <h3>두 점 사이의 거리 구하기</h3>
      <u>math.h파일</u><br><br>
      sqrt로 제곱근을 구할수 있다. // sqrt(값)<br><br>
      pow로 거듭제곱을 구할 수 있다. // pow(값, 지수)<br><br>
      <img src="images/c/절대값 구하는 함수.png" width="50%"><br><br>
    </p>

    <p>
      <h3>구조체 정렬</h3>
      C 언어에서는 구조체를 정렬할 때 멤버 중에서 가장 큰 자료형 크기의 배수로 정렬한다. // char a, int b 가 정의된 구조체의 크기는 8바이트.<br><br>
      구조체 정렬크기 조정하기 -> #pragma pack(push, 1) // 1바이트 크기로 정렬<br><br>
      #pragma pack(push, 1) // 1바이트 크기로 정렬<br>
      struct PacketHeader {<br>
      &nbsp&nbspchar flags; // 1바이트<br>
      &nbsp&nbspint seq; // 4바이트<br>
      };<br>
      #pragma pack(pop) // 정렬 설정을 이전 상태(기본값)로 되돌림<br>
      <br>
      <hr><br>
      구조체 변수를 선언할 때 { 0, }처럼 중괄호를 사용하여 0으로 초기화할 수 있었지만, 변수에만 사용할 수 있고 malloc 함수로 할당한 메모리에는 사용할 수 없었다.<br>
      일일이 멤버에 값을 설정하거나 중괄호를 사용하지 않고, 구조체 변수나 메모리의 내용을 한꺼번에 값을 설정하려면 memset 함수를 사용하면 된다.
      <blockquote>memset(구조체포인터, 설정할값, sizeof(struct 구조체));<br>
        memset(p1, 0, sizeof(struct Point2D)); // p1을 구조체 크기만큼 0으로 설정<br></blockquote>
      <br>
      <hr><br>
      구조체를 다른 곳에 복사할 경우가 자주 있다. 이때는 memcpy 함수를 사용하여 메모리의 내용을 다른 곳으로 복사할 수 있다. // string.h에 선언<br>
      <blockquote>memcpy(목적지포인터, 원본포인터, 크기);<br>
        memcpy(p2, p1, sizeof(struct Point2D)); // Point2D 구조체 크기만큼 p1의 내용을 p2로 복사<br></blockquote>
      구조체 변수에서 동적 메모리로, 동적 메모리에서 구조체 변수로 내용 복사도 할 수 있다.<br>
      <blockquote>memcpy(p2, &p1, sizeof(struct Point2D)); // 구조체 변수에서 동적 메모리로 복사<br>
        memcpy(&p2, p1, sizeof(struct Point2D)); // 동적 메모리에서 구조체 변수로 복사</blockquote>
      <br>
      <hr><br>
      구조체 요소가 한꺼번에 뭉쳐져 있는 배열이 아닌 요소마다 메모리를 할당하고 싶을 수도 있다.<br>
      이때는 구조체 포인터 배열을 만들고 malloc 함수로 각 요소에 메모리를 할당하면 된다. // struct 구조체이름 *포인터이름[크기];<br>
      <blockquote>struct Point2D *p[3]; // 크기가 3인 구조체 포인터 배열 선언<br><br>

        // 구조체 포인터 배열 전체 크기에서 요소(구조체 포인터)의 크기로 나눠서 요소 개수를 구함<br>
        for (int i = 0; i < sizeof(p) / sizeof(struct Point2D *); i++) // 요소 개수만큼 반복<br>
          {
          <blockquote>
            p[i] = malloc(sizeof(struct Point2D)); // 각 요소에 구조체 크기만큼 메모리 할당
          </blockquote>
          }
      </blockquote>
      구조체 포인터 배열의 사용이 끝났다면 메모리를 해제해야 한다. 다음과 같이 배열 크기만큼 반복하면서 각 요소에 할당된 동적 메모리를 해제한다.
      <blockquote>
        for (int i = 0; i < sizeof(p) / sizeof(struct Point2D *); i++) // 요소 개수만큼 반복<br>
          {
          <blockquote>
            free(p[i]); // 각 요소의 동적 메모리 해제
          </blockquote>
          }
      </blockquote>
      <br>
      <hr><br>
      // 구조체에 저장된 3000명의 인적정보 삭제하기<br><br>
      <img src="images/c/구조체에 저장된 3000명의 인적정보 삭제하기.png" width="30%"><br><br>
    </p>

    <p>
      <h3>공용체</h3>
      공용체는 멤버 중에서 가장 큰 자료형의 공간을 공유한다. 따라서 어느 한 멤버에 값을 저장하면 나머지 멤버의 값은 사용할 수 없는 상태가 된다.<br>
      그래서 공용체의 멤버는 한 번에 하나씩 쓰면 값을 정상적으로 사용할 수 있다.<br>
      공용체는 여러 멤버에 동시에 접근하지 않는 경우 같은 메모리 레이아웃에 멤버를 모아둘 때 사용한다.<br>
      특히 공용체는 임베디드 시스템이나 커널 모드 디바이스 드라이버 등에서 주로 사용된다.<br><br>

      구조체와 마찬가지로 공용체도 포인터를 선언할 수 있으며 공용체 포인터에는 malloc 함수를 사용하여 동적 메모리를 할당할 수 있다.<br>
      <blockquote>union 공용체이름 *포인터이름 = malloc(sizeof(union 공용체이름));</blockquote>

      구조체 안에 구조체와 공용체가 들어갈 수 있고, 반대로 공용체 안에 구조체와 공용체가 들어갈 수도 있다.<br>
      만약 구조체를 다른 곳에서는 쓰지 않고 특정 구조체 안에서만 쓴다면 구조체 안에 구조체를 정의하는 게 더 편리하다.<br>
      <br>//구조체 안의 구조체 멤버에 메모리 할당하기<br>
      <img src="images/c/구조체안의 구조체멤버에 메모리 할당하기.png" width="50%"><br><br>

      //익명구조체와 익명공용체<br>
      <img src="images/c/익명구조체와 익명공용체.png" width="50%"><br><br>
    </p>

  </blockquote>

  <blockquote>
    <h2>
      <hr>
      <hr>2/16</h2>
    <hr>
    <hr>

    <p>
      <h3>구조체 비트 필드 사용하기</h3>
      <blockquote>struct Flags {
        <blockquote>
          unsigned int a : 1; // a는 1비트 크기<br>
          unsigned int b : 3; // b는 3비트 크기<br>
          unsigned int c : 7; // c는 7비트 크기<br>
        </blockquote>
        };
      </blockquote>
      <img src="images/c/구조체 필드의 구성.png" width="50%"><br><br>
      //비트 필드의 값을 공용체로 한번에 사용하는법<br>
      <img src="images/c/비트 필드의 값을 공용체로 한번에 사용.png" width="50%"><br><br>
      <br>
      <hr><br>
      // 열거형<br>
      <img src="images/c/enum 열거형 사용.png" width="50%"><br><br>
      // 열거형은 switch분기을 사용할 떄 유용하다.<br>
      <img src="images/c/enum 열거형 switch에서 분기로사용.png" width="50%"><br><br>
      // 열거형을 for에 활용하기<br>
      <img src="images/c/enum 열거형 for에서 사용.png" width="50%"><br><br>
    </p>
    <br>
    <hr><br>

    <p>
      <h3>자료형 변환하기</h3>
      형 변환은 구조체와 포인터를 조합하여 사용할 때 유용하게 활용된다.<br><br>
      // 명시적 형변환<br>
      <img src="images/c/명시적 형변환.png" width="50%"><br><br>
      // 포인터끼리의 형변환 -> (자료형 *)포인터<br>
      <img src="images/c/포인터끼리 명시적 형변환.png" width="50%"><br><br>
      // void 포인터는 자료형이 정해져 있지 않으므로 역참조 연산을 할 수 없다. 하지만 void 포인터를 다른 자료형으로 변환하면 역참조를 할 수 있다.<br>
      <img src="images/c/void 형변환.png" width="50%"><br><br>
      <br>
      <hr>
      <br>
      <hr>
      // 구조체 포인터 형변환<br>
      <blockquote>
        (struct 구조체이름 *)포인터<br>
        ((struct 구조체이름 *)포인터)->멤버
      </blockquote>
      <img src="images/c/구조체 포인터 형변환.png" width="50%"><br><br>
    </p>
    <br>
    <hr><br>

    <p>
      <h3>포인터 연산 사용하기</h3>
      포인터 연산은 포인터 변수에 +, - 연산자를 사용하여 값을 더하거나 뺀다. 또는, ++, -- 연산자를 사용하여 값을 증가, 감소시킨다.<br>
      <blockquote>
        포인터 + 값<br>
        포인터 - 값
      </blockquote>
      // 증가, 감소 연산시<br>
      <img src="images/c/포인터 연산 증가, 감소 연산자.png" width="50%"><br><br>
      // void 포인터 연산시<br>
      <img src="images/c/void 포인터 연산.png" width="50%"><br><br>
      // memset 함수로 중간부터 값을 설정하는 법<br>
      <img src="images/c/memset 함수로 중간부터 값을 설정하는 법.png" width="50%"><br><br>

    </p>
    <br>
    <hr><br>

    <p>다음은 60. 함수 사용하기를 공부한다.<br>
    </p>

  </blockquote>

  <blockquote>
    <h2>
      <hr>
      <hr>2/17</h2>
    <hr>
    <hr>

    <p>
      <h3>함수 사용하기</h3>
      함수 반환값의 자료형과 반환값을 저장할 변수의 자료형이 다를 때도 있다. 이때는 자료형 변환규칙을 따른다.
      <blockquote>
        return (자료형)변수;<br>
        return (자료형)값;<br>
        변수 = (자료형)함수();
      </blockquote>
      // 포인터 반환하기<br>
      <img src="images/c/포인터 함수 반환.png" width="50%"><br><br>

      // void 포인터는 강제로 변환하지 않더라도 다양한 형태의 포인터에 넣을 수 있다.<br>
      <img src="images/c/void 포인터는 다양한 포인터로 자동 변환됨.png" width="25%"><br><br>

      C 언어의 함수는 값을 하나만 반환할 수 있다. 그럼 인적 정보를 반환값으로 얻어오려면 어떻게 해야 할까?<br>
      이때는 함수에서 반환값으로 구조체를 활용하면 편리하다.<br>

      // 매개변수, 파라미터, 인자, 인수, 아규먼트 사용하기<br>
      <img src="images/c/매개변수, 파라미터, 인자, 인수, 아규먼트.png" width="50%"><br><br>

      <br>
      <hr><br>
      // 디버거 단축키
      <blockquote>
        중단점 삽입/삭제: F9<br>
        디버깅 시작 및 계속: F5<br>
        디버깅 중지: Shift+F5<br>
        프로시저 단위 실행: F10<br>
        한 단계씩 코드 실행: F11<br>
        프로시저 나가기: Shift+F11<br>
      </blockquote>

      <br>
      <hr><br>

      <h3>함수에서 포인터 매개변수 사용하기</h3>
      // 포인터 매개변수를 이용한 함수 swap<br>
      <img src="images/c/포인터 매개변수를 이용한 함수 swap.png" width="50%"><br><br>

      void 포인터 매개변수를 사용하면 자료형 변환을 하지 않아도 모든 자료형을 함수에 넣을 수 있다.<br>
      <br>
      <hr><br>
      <h4>*********************63.7 연습문제*********************</h4>
      <img src="images/c/63.7 연습문제.png" width="50%"><br><br>
      <img src="images/c/63.7 연습문제 풀이.png" width="50%"><br><br>

      // 2차원 배열은 **이고, 2차원 배열을 주소로 전달하고 싶다면 ***이 된다.<br>
      // 3차원 배열은 ***이고, 3차원 배열을 주소로 전달하고 싶다면 ****이 된다.<br>
      <br>
      <hr><br>

      다음 공부는 63.7을 한번 더 본다.<br>

    </p>

  </blockquote>

  <blockquote>
    <h2>
      <hr>
      <hr>2/18</h2>
    <hr>
    <hr>

    <p>
      <h3>배열 매개변수 사용</h3>
      함수에서 2차원 배열을 매개변수로 사용하려면 매개변수 이름 뒤에 [ ][가로크기] (대괄호)를 두 개 붙이고 가로 크기를 지정하거나 괄호로 묶은 포인터 뒤에 [ ]를 붙이고 가로 크기를 지정한다.<br>
      <br>//2차원 배열을 함수의 매개변수로 사용하기<br>
      <img src="images/c/2차원 배열을 함수의 매개변수로 사용하기.png" width="50%"><br><br>
      <br>
      <hr><br>

      <h3>함수에서 가변 인자 사용하기</h3>
      함수에서 가변 인자를 정의할 때는 고정 매개변수가 한 개 이상 있어야 하며<br>
      고정 매개변수 뒤에 ...을 붙여 매개변수의 개수가 정해지지 않았다는 표시를 해준다. 단, ... 뒤에는 다른 매개변수를 지정할 수 없다.<br>
      <blockquote>
        반환값자료형 함수이름(자료형 고정매개변수, ...)<br>
        {<br><br>

        }
      </blockquote>
      // ...부분 매개변수 사용<br>
      <img src="images/c/가변인자 매개변수 사용.png" width="50%"><br><br>
      ...으로 들어온 가변 인자를 사용하려면 stdarg.h 헤더 파일에 정의된 매크로를 이용해야 한다. 따라서 #include로 stdarg.h 헤더 파일을 포함해줍니다.<br>
      stdarg.h에 정의된 가변 인자 처리 매크로는 다음과 같다.<br>
      <blockquote>
        va_list: 가변 인자 목록. 가변 인자의 메모리 주소를 저장하는 포인터입니다.<br>
        va_start: 가변 인자를 가져올 수 있도록 포인터를 설정합니다.<br>
        va_arg: 가변 인자 포인터에서 특정 자료형 크기만큼 값을 가져옵니다.<br>
        va_end: 가변 인자 처리가 끝났을 때 포인터를 NULL로 초기화합니다.
      </blockquote>
      // 자료형이 다른 가변 인자 만들기<br>
      <img src="images/c/자료형이 다른 가변 인자 만들기.png" width="50%"><br><br>
      <br>
      <hr><br>

      <h3>함수 포인터</h3>
      함수를 배열 또는 구조체에 넣거나, 함수 자체를 함수의 매개변수로 넘겨주고, 반환값으로 가져올 수는 없을까?<br>
      C 언어는 이런 상황을 위해서 함수 포인터라는 것을 만들어두었다.<br>
      함수 포인터는 함수를 저장하는 포인터를 뜻하며 함수 포인터를 주고 받거나 함수 포인터로 함수를 호출할 수 있다.<br><br>
      함수 포인터는 먼저 함수의 반환값 자료형을 지정해주고, 함수 포인터 이름 앞에 * (애스터리스크)를 붙인 뒤 ( ) (괄호)로 묶어준다.<br>
      그리고 다시 괄호를 붙여 함수라는 것을 알려준다. <blockquote>반환값자료형 (*함수포인터이름)();<br></blockquote>
      <img src="images/c/함수 포인터 사용.png" width="50%"><br><br>

      // 반환값과 매개변수가 있는 함수 포인터
      <blockquote>반환값자료형 (*함수포인터이름)(매개변수자료형1, 매개변수자료형2);<br></blockquote>
      <img src="images/c/반환값과 매개변수가 있는 함수 포인터 사용.png" width="50%"><br><br>

      <br>
      <hr><br>
      다음은 69.0 함수 포인터 활용하기를 한다.<br>

    </p>

  </blockquote>

  <blockquote>
    <h2>
      <hr>
      <hr>2/20</h2>
    <hr>
    <hr>

    <p>
      <h3>함수 포인터 활용하기</h3>
      함수 포인터 배열은 함수 포인터를 선언할 때 함수 포인터 이름 뒤에 [ ] 대괄호 안에 배열의 크기를 지정하면 된다.
      <blockquote>
        <h5>반환값자료형 (*함수포인터이름[크기])(매개변수자료형1, 매개변수자료형2);</h5>
      </blockquote>
      // 함수 포인터 배열을 선언하는 동시에 초기화하기<br>
      <img src="images/c/함수 포인터 배열을 선언하는 동시에 초기화하기.png" width="50%"><br><br>

      // 함수 포인터를 구조체 멤버로 사용하기<br>
      <img src="images/c/함수 포인터를 구조체 멤버로 사용하기.png" width="50%"><br><br>

      // 함수 포인터를 함수의 매개변수로 사용하기<br>
      <img src="images/c/함수 포인터를 함수의 매개변수로 사용하기.png" width="50%"><br><br>

      // 함수 포인터를 함수의 반환값으로 사용하기<br>
      <img src="images/c/함수 포인터를 함수의 반환값으로 사용하기.png" width="50%"><br><br>
      <br>
      <hr><br>
      // 함수 포인터 정리<br>
      <img src="images/c/함수 포인터 정리.png" width="50%"><br><br>

      <br>
      <hr>
      어려운 문법이 계속 등장해 아직도 헷갈린다. 일단 넘어가고 다음에 다시보겠다. 다음은 70. 파일에서 문자열을 읽고 쓰기 를 하겠다.<br>
    </p>

  </blockquote>

  <blockquote>
    <h2>
      <hr>
      <hr>2/26</h2>
    <hr>
    <hr>

    <p>
      <h3>파일에서 문자열을 읽고 쓰기</h3>
      파일에 문자열을 쓸 때는 먼저 fopen 함수로 파일을 열어서 파일 포인터를 얻은 뒤 fprintf 함수를 사용한다(stdio.h 헤더 파일에 선언되어 있다).<br><br>
      <blockquote>
        // FILE *포인터이름 = fopen(파일명, 파일모드);<br>
        FILE *fopen(char const *_FileName, char const *_Mode);<br>
        성공하면 파일 포인터를 반환, 실패하면 NULL을 반환
      </blockquote>

      <blockquote>
        // fprintf(파일포인터, 서식, 값1, 값2, ...);<br>
        int fprintf(FILE * const _Stream, char const * const _Format, ...);<br>
        성공하면 쓴 문자열의 길이를 반환, 실패하면 음수를 반환
      </blockquote>

      <blockquote>
        // fclose(파일포인터);<br>
        int fclose(FILE *_stream);<br>
        성공하면 0을 반환, 실패하면 EOF(-1)를 반환
      </blockquote>

      <img src="images/c/파일 모드.png" width="50%"><br><br>

      <br>
      <hr><br>
      파일에서 문자열을 읽을 때는 먼저 fopen 함수로 파일을 열어서 파일 포인터를 얻은 뒤 fscanf 함수를 사용한다.
      <blockquote>
        // fscanf(파일포인터, 서식, 변수의주소1, 변수의주소2, …);<br>
        int fscanf(FILE * const _Stream, char const * const _Format, ...);<br>
        성공하면 읽어온 값의 개수를 반환, 실패하면 EOF(-1)를 반환
      </blockquote>

      <br>
      <hr><br>
      fputs 함수를 사용하면 문자열을 그대로 파일에 쓸 수 있다(stdio.h 헤더 파일에 선언되어 있다).
      <blockquote>
        // fputs(버퍼, 파일포인터);<br>
        int fputs(char const *_Buffer, FILE *_Stream);<br>
        성공하면 음수가 아닌 값을 반환, 실패하면 EOF(-1)을 반환
      </blockquote>

      <br>
      fwrite 함수를 사용하여 문자열을 파일에 쓸 수 있다.(stdio.h 헤더 파일에 선언되어 있다).
      <blockquote>
        // fwrite(버퍼, 쓰기크기, 쓰기횟수, 파일포인터);<br>
        size_t fwrite(void const *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream);<br>
        성공한 쓰기 횟수를 반환, 실패하면 지정된 쓰기 횟수보다 작은 값을 반환
      </blockquote>

      <br>
      <hr><br>
      fgets 함수를 사용하여 파일에서 문자열을 읽을 수 있다.(stdio.h 헤더 파일에 선언되어 있다).
      <blockquote>
        // fgets(버퍼, 버퍼크기, 파일포인터);<br>
        char *fgets(char *_Buffer, int _MaxCount, FILE *_Stream);<br>
        성공하면 읽은 문자열의 포인터를 반환, 실패하면 NULL을 반환
      </blockquote>
      // fgets 함수에서 주의 해야 할 점<br>
      <img src="images/c/fgets 함수의 파일 읽는 방식.png" width="50%"><br><br>

      fread 함수를 사용하여 파일에서 문자열을 읽을 수 있다.
      <blockquote>
        fread(버퍼, 읽기크기, 읽기횟수, 파일포인터);<br>
        size_t fread(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream);<br>
        성공한 읽기 횟수를 반환, 실패하면 지정된 읽기 횟수보다 작은 값을 반환
      </blockquote>
      // 파일을 읽을 때 사용할 임시 공간(버퍼)를 선언해야 하는데 fread 함수를 사용할 때는 char 배열을 선언한 뒤 반드시 0으로 초기화해야 한다<br>
      (char 포인터에 동적 메모리를 할당한 뒤 0으로 초기화해도 된다).<br>
      만약 앞에서 buffer를 0(NULL)으로 초기화하지 않고 fread로 파일을 읽으면 "Hello, world!"이외에도 쓸데없는 값들이 함께 출력된다.
    </p>
    <br>
    <hr><br>

    <p>
      <h3>파일 읽기/쓰기 위치 활용하기</h3>
      파일의 크기를 구할 때는 fseek, ftell 함수를 사용한다.<br>
      <blockquote>
        fseek(파일포인터, 이동할크기, 기준점);<br>
        int fseek(FILE *_Stream, long _Offset, int _Origin);<br>
        성공하면 0, 실패하면 -1을 반환<br><br>

        ftell(파일포인터);<br>
        long ftell(FILE *_Stream);<br>
        파일 포인터의 현재 위치를 반환, 실패하면 -1을 반환
      </blockquote>
      // fseek, ftell 함수 사용<br>
      <img src="images/c/fseek, ftell 함수 사용.png" width="50%"><br><br>
      // fseek의 기준점<br>
      <img src="images/c/fseek의 기준점.png" width="50%"><br><br>

      <br>
      <hr><br>
      // 파일의 크기를 구하는 방법을 이용하여 파일 크기만큼 버퍼를 생성하고, 파일을 읽기<br>
      <img src="images/c/파일의 크기를 구하는 방법을 이용하여 파일 크기만큼 버퍼를 생성하고, 파일을 읽기.png" width="50%"><br><br>

      // 파일 포인터를 파일의 처음으로 이동시킬 때 fseek(fp, 0, SEEK_SET); 대신 rewind 함수를 사용해도 된다(stdio.h 헤더 파일에 선언되어 있다).<br>
      <blockquote>
        rewind(fp); // rewind 함수를 사용하여 파일 포인터를 파일의 처음으로 이동시킴<br>
        count = fread(buffer, size, 1, fp); // hello.txt에서 파일 크기만큼 값을 읽음
      </blockquote>
      <br>
      <hr><br>

      feof 함수는 현재 파일 포인터가 파일의 끝인지 검사한다(stdio.h 헤더 파일에 선언되어 있다).<br>
      // 제한된 버퍼로 파일 전체를 읽기<br>
      <img src="images/c/제한된 버퍼로 파일 전체를 읽기.png" width="50%"><br><br>
      ->fread 함수로 파일을 읽을 때는 buffer를 선언한 자료형이 char이므로 sizeof(char)를 지정하여 1바이트 크기로 4번 읽는다.<br>
      이렇게 하면 fread로 파일을 읽었을 때 읽은 크기만큼 반환값이 나오게 되므로 파일을 읽은 전체 크기를 구할 수 있다.<br>

  </blockquote>

  <blockquote>
    <h2>
      <hr>
      <hr>2/27</h2>
    <hr>
    <hr>

    <p>
      <h3>파일에서 구조체를 읽고 쓰기</h3>
      파일에 구조체의 내용을 쓰려면 fwrite 함수를 사용한다.
      <blockquote>
        // fwrite(버퍼, 쓰기크기, 쓰기횟수, 파일포인터);<br>
        size_t fwrite(void const *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream);<br>
        성공한 쓰기 횟수를 반환, 실패하면 지정된 쓰기 횟수보다 작은 값을 반환
      </blockquote>
      <img src="images/c/파일에 구조체 쓰기.png" width="50%"><br><br>
      <br>
      <hr><br>
      파일에서 구조체의 내용을 읽으려면면 fread 함수를 사용한다.
      <blockquote>
        // fread(버퍼, 읽기크기, 읽기횟수, 파일포인터);<br>
        size_t fread(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream);<br>
        성공한 읽기 횟수를 반환, 실패하면 지정된 읽기 횟수보다 작은 값을 반환
      </blockquote>
      바이너리 파일을 읽어서 구조체에 저장할 때는 구조체 멤버의 크기뿐만 아니라 순서도 중요하다.<br>
      만약 구조체 멤버의 순서가 달라진다면 값의 일부만 가져오거나 여러 개의 값을 묶어서 가져올 수도 있으므로 주의해야 한다.<br>

      <br>
      <hr><br>
      <h3>배열 정렬하기</h3>
      // 거품 정렬<br>
      <img src="images/c/거품 정렬.png" width="50%"><br><br>

      <br>
      <hr><br>
      퀵 정렬 함수. 퀵 정렬 함수에는 정렬할 배열 또는 메모리의 주소, 요소 개수, 요소 크기, 비교 함수를 넣어준다(stdlib.h 헤더 파일에 선언되어 있다).<br>
      <blockquote>
        qsort(정렬할배열, 요소개수, 요소크기, 비교함수);<br>
        qsort(정렬할메모리주소, 요소개수, 요소크기, 비교함수);
      </blockquote>
      실제로 정렬을 한다면 정렬할 배열의 자료형도 제각각이고 비교 방식도 여러 가지다. 그래서 비교 함수는 우리가 구현해서 함수의 메모리 주소(함수 포인터)를 넣어주게 된다.<br><br>
      // qsort 사용법<br>
      <img src="images/c/qsort 사용법.png" width="50%"><br><br>
      **내림차순 비교 함수는 오름차순에서 부등호만 반대로 바꾸면 된다.<br>

      <br>
      <hr><br>
      <h3>연결리스트 구현하기</h3>
      연결 리스트는 데이터가 담긴 노드(메모리 공간)를 일렬로 연결해놓았다고 해서 연결 리스트라고 부르며 특징은 다음과 같다.<br>
      <blockquote>
        리스트의 중간 지점에 노드를 손쉽게 추가하거나 삭제할 수 있다.<br>
        특정 노드를 찾으려면 노드를 모두 검색해야 한다(최악의 경우).<br>
        크기가 고정되어 있지 않다.
      </blockquote>
      // 연결리스트 사용<br>
      <img src="images/c/연결리스트 사용.png" width="50%"><br><br>
      연결 리스트에서 노드를 추가하는 규칙
      <blockquote>
        1. 노드에 메모리 할당<br>
        2. next 멤버에 다음 노드의 메모리 주소 저장<br>
        3. data 멤버에 데이터 저장<br>
        4. 마지막 노드라면 next 멤버에 NULL 저장
      </blockquote>
      // 연결리스트 노드 추가<br>
      <img src="images/c/연결리스트 노드 추가.png" width="50%"><br><br>
      // 연결리스트 노드 삭제<br>
      <img src="images/c/연결리스트 노드 삭제.png" width="50%"><br><br>

      <br>
      <hr><br>
      <h3>매크로 사용하기</h3>
      // #define 매크로이름 값<br><br>
      #define으로 정의한 매크로를 해제하고 싶을 때는 #undef를 사용한다.<br>
      // #undef 매크로이름<br><br>
      #define은 함수 모양의 매크로도 정의할 수 있다.
      <blockquote>
        #define 매크로이름(x) 함수(x)<br>
        #define 매크로이름(x) 코드조합
      </blockquote>
      <img src="images/c/함수모양 매크로 정의.png" width="50%"><br><br>

      #define은 줄바꿈이 일어날 때 \를 사용하여 여러 줄을 매크로로 만들 수 있다. 단, 맨 마지막 줄은 \를 사용하지 않아도 된다.<br>
      <img src="images/c/여러줄을 묶어서 매크로 정의하기.png" width="50%"><br><br>

      여러 줄로 된 매크로를 사용할 때는 조건문, 반복문 사용에 주의해야 한다(코드가 늘어나기 때문).<br><br><br>

      // 두 변수의 값을 바꾸는 매크로 정의하기<br>
      <img src="images/c/두 변수의 값을 바꾸는 매크로 정의하기.png" width="50%"><br><br>

      -> #define으로 SWAP을 정의할 때 바꿀 변수가 들어갈 a와 b 그리고 자료형이 들어갈 type을 지정해준다.<br>
      함수에서는 자료형을 매개변수에 그대로 전달할 수 없지만 매크로는 전달하는 것이 아니라 지정한 코드 자체가 바뀌게 되므로 자료형도 지정할 수 있다.<br><br>

      -> 여기서 눈 여겨볼 부분은 do while (0)이다. 별 의미 없는 코드 같지만 실제로는 중요한 역할을 담당한다.<br>
      do while (0)은 { } (중괄호)로 묶여 있기 때문에 안에서 변수를 마음대로 선언할 수 있고, 선언된 변수는 do while (0)을 벗어나면 변수가 사라진다.<br>
      즉, SWAP 매크로를 계속 사용했을 때 같은 이름으로 된 변수가 여러 개 생기지만 컴파일 에러를 방지할 수 있다.<br>
      <br>
      <hr>

      // 매크로를 정의할 때는 연산자 우선순위를 주의해야 한다.<br>
      -> 연산자 우선순위에 따라서 의도치 않게 계산 결과가 바뀌는 문제를 해결하려면 매크로의 인수와 결과를 모두 ( ) (괄호)로 묶어주면 된다.<br>
      <br>
      <hr>

      //#define에서 ##을 사용하면 여러 코드(값)를 붙일 수 있다.<br>
      &nbsp&nbsp#define 매크로이름(a, b) a##b
    </p>

  </blockquote>

  <blockquote>
    <h2>
      <hr>
      <hr>2/29</h2>
    <hr>
    <hr>

    <p>
      <h3>조건부 컴파일과 파일 포함 사용하기</h3>
      조건부 컴파일은 #ifdef와 #endif 지시자를 사용하여 정의한다. #ifdef에 매크로를 지정하면 해당 매크로가 정의되어 있을 때만 코드를 컴파일한다.<br><br>
      // 조건부 컴파일 예시<br>
      <img src="images/c/조건부 컴파일 예시.png" width="50%"><br><br>
      printf안에서 사용한 __DATE__, __TIME__, __FILE__, __LINE__는 컴파일러에서 제공하는 매크로이며 디버그 코드를 작성할 때 유용하다.<br>
      <blockquote>
        __DATE__: 컴파일한 날짜(실행 시점의 현재 날짜가 아님)<br>
        __TIME__: 컴파일한 시간(실행 시점의 현재 시간이 아님)<br>
        __FILE__: __FILE__ 매크로가 사용된 헤더, 소스 파일<br>
        __LINE__: __LINE__ 매크로가 사용된 줄 번호<br>
      </blockquote>
      // #if로 값 또는 식을 판별하여 조건부 컴파일<br>
      <img src="images/c/if로 값 또는 식을 판별하여 조건부 컴파일.png" width="50%"><br><br>

      #elif와 #else도 사용가능하다. 단, #elif로 매크로를 판별할 때는 defined와 함께 사용해야 한다.<br>
      <img src="images/c/elif와 else를 사용하여 조건부 컴파일.png" width="50%"><br><br>
    </p>
    <br>
    <hr>
    <p>
      <h3>파일 포함하기</h3>
      1. 헤더(h) 파일을 생성한다.
      <blockquote>
        " ": 현재 소스 파일을 기준으로 헤더 파일을 포함하고, 헤더 파일을 찾지 못할 경우 컴파일 옵션에서 지정한 헤더 파일 경로를 따른다.<br>
        (솔루션 탐색기에서 프로젝트 선택 > 메인 메뉴의 프로젝트(P) > 속성(P) > C/C++ > 일반 > 추가 포함 디렉터리)<br>
        <blockquote>
          예) "message.h": 현재 소스 파일과 같은 경로에 있는 message.h 파일을 포함합니다.<br>
          예) "inc/message.h": 현재 소스 파일 경로에서 inc 디렉터리 아래의 message.h 파일을 포함합니다.<br>
          예) "../message.h": 현재 소스 파일 경로의 상위 디렉터리에 있는 message.h 파일을 포함합니다.
        </blockquote>
      </blockquote>
      2. 헤더 파일을 포함한다.
    </p>
    <br>
    <hr>
    <p>
      <h3>여러 소스 파일 사용하기</h3>
      <img src="images/c/여러 소스 파일 사용하기.png" width="30%"><br><br>

      // 예제<br>
      <img src="images/c/예제 간략도.png" width="30%"><br><br>

      // 예제 헤더 파일 포함관계<br>
      <img src="images/c/예제 헤더 파일 포함관계.png" width="30%"><img src="images/c/예제 모양.png" width="70%"><br><br>
    </p>
    <br>
    <hr>
    <p>
      <h3>전역 변수 사용하기</h3>

      int num1; // 전역 변수는 초깃값을 지정하지 않으면 0으로 초기화된다.<br><br>
      // 헝가리안 표기법과 전역 변수<br>
      <img src="images/c/헝가리안 표기법과 전역 변수.png" width="50%"><br><br>

      // 다른 소스 파일(외부)에 선언된 전역 변수를 사용할 때는 extern 키워드를 사용한다.<br>
      <blockquote>extern 자료형 전역변수;</blockquote>
      <img src="images/c/extern 키워드.png" width="50%"><br><br>
    </p>

  </blockquote>

  <blockquote>
    <h2>
      <hr>
      <hr>3/1</h2>
    <hr>
    <hr>

    <p>
      <h3>기억 부류 사용자 지정하기</h3>
      C 언어의 변수는 기억 부류 지정자(storage class specifier)를 사용하여 다양한 특성을 지정할 수 있다.<br><br>
      <img src="images/c/기억 부류 지정자.png" width="50%"><br><br>

      전역 변수(extern)와 정적 변수를 선언할 때 값을 초기화했으면 데이터 섹션(.data)에 생성되고, 초기화하지 않았으면 BSS 섹션(.bss)에 생성되며 0이 들어간다.<br><br>

      변수가 사라지지 않게 하려면 정적 변수를 사용해야 한다.<blockquote>static 자료형 변수이름;</blockquote>

      <img src="images/c/정적 변수 사용.png" width="50%"><br><br>
      -> static int num1 = 0;은 프로그램이 시작될 때 변수를 초기화하며 increaseNumber 함수가 호출될 때는 변수를 초기화하지 않고 무시한다.<br><br>

      static으로 선언한 변수를 extern으로 사용하려고 하면 컴파일(링크) 에러가 발생한다.<br>
      즉, 정적 전역 변수는 자신이 선언된 소스 파일 안에서만 사용할 수 있고, 외부에서는 가져다 쓸 수 없다.<br>
      즉, 전역 변수에 static을 붙이면 변수의 범위를 파일 범위로 제한하는 효과를 낸다.<br>
      <img src="images/c/정적 전역 변수는 외부에서 사용할수 없음.png" width="50%"><br><br>
      -> 정적 변수는 초깃값을 지정하지 않으면 0으로 초기화된다.<br>
      -> 정적 변수는 함수의 매개변수 값으로 사용할 수 없다.<br>
      <img src="images/c/정적 변수와 매개변수.png" width="50%"><br><br>

      // 정적 함수를 사용하면 같은 이름을 가진 함수를 파일마다 만들 수 있다. 따라서 정적 함수는 기능이 여러 파일로 분리되어 있을 때 각 파일 안에서만 사용하는 기능을 구현할 수 있다.
      <img src="images/c/파일과 정적 함수의 범위.png" width="50%"><br><br>
    </p>
    <br>
    <hr><br>

    <p>
      <h3>레지스터 변수 사용하기</h3>
      변수를 선언할 때 앞에 register를 붙이면 변수는 메모리 대신 CPU의 레지스터를 사용한다. 따라서 일반 변수보다 속도가 빠르다.<br>
      <blockquote>register 자료형 변수이름;</blockquote>
      <img src="images/c/register 변수 사용.png" width="50%"><br><br>

      -> 레지스터 변수는 변수가 CPU 레지스터만 사용하므로 메모리에는 생성되지 않는다. 따라서 &로 메모리 주소를 구할 수 없다.<br>
      단, 레지스터 변수에 메모리 주소는 저장할 수 있으므로 역참조 연산자 *를 사용할 수 있다.<br><br>
      -> 레지스터 변수는 반복 횟수가 매우 많을 때 유용하다.<br>
      -> register는 지역 변수에만 사용할 수 있고 전역 변수에는 사용할 수 없다.<br><br>

      // 참고. 형 한정자<br>
      <img src="images/c/형 한정자.png" width="50%"><br><br>
    </p>
    <br>
    <hr><br>

    <p>
      <h3>실행 파일 옵션 사용하기</h3>
      C 언어의 main 함수는 다음과 같이 실행 파일 옵션을 매개변수로 받을 수 있다.<br>
      <blockquote>int main(int argc, char *argv[]);</blockquote>
      <img src="images/c/main 함수에서 실행 파일 옵션 받기.png" width="50%"><br><br>

      // 실행 파일 옵션<br>
      <img src="images/c/실행 파일 옵션.png" width="50%"><br><br>

      // 80.3 연습문제: 덧셈 프로그램 만들기<br>
      <img src="images/c/80.3 연습문제 덧셈 프로그램 만들기.png" width="50%"><br><br>
    </p>
    <br>
    <hr><br>

    <p>
      <h3>81.0 실전 예제: 비트맵 파일을 아스키 아트로 변환하기</h3>
      비트맵 파일은 바이너리 형식이므로 메모장 등 텍스트 편집기로 열어도 내용을 알아볼 수 없다. 따라서 비트맵 파일에서 픽셀 정보를 읽으려면 먼저 비트맵 파일의 구조를 알아야 한다.<br>
      <img src="images/c/비트맵 파일의 구조.png" width="50%"><br><br>
      비트맵 파일 헤더는 비트맵 파일 식별 정보, 파일 크기, 데이터 위치 등의 정보를 담고 있으며<br>
      <img src="images/c/비트맵 파일 헤더의 구조.png" width="50%"><br><br>
      DIB(Device Independent Bitmap) 헤더는 가로, 세로 크기, 해상도, 픽셀의 비트 수 등 그림의 자세한 정보를 담고 있다.<br>
      <img src="images/c/비트맵 정보 헤더의 구조.png" width="40%"><br><br>
      픽셀 데이터에는 그림 파일의 실제 색상 정보가 들어간다. 단, 픽셀당 색상 수가 16비트 미만일 때는 색상 테이블에 따로 색상 정보를 저장하고, 픽셀 데이터에서는 색상 테이블의 인덱스를 저장한다.<br>
      우리는 24색 비트맵 파일을 사용할 것이므로 색상 테이블은 처리하지 않는다.<br>
      <img src="images/c/24비트 비트맵의 픽셀 구조.png" width="15%"><br><br>

      -> 비트맵 파일의 구조를 알아보았으니 이제 비트맵 구조체를 작성한다. 이때 주의할 점은 반드시 구조체를 1바이트 크기로 정렬해야 한다는 점이다.<br>
      즉, 비트맵 파일에서 각 정보는 위치와 크기가 정확하게 정해져 있으므로 반드시 구조체의 크기와 형태 그대로 읽어야 한다.<br>
      <img src="images/c/비트맵 구조체.png" width="50%"><br><br>

      // 비트맵 파일을 ASCII 문자로 저장하는 과정<br>
      <img src="images/c/비트맵 파일을 ASCII 문자로 저장하는 과정.png" width="50%"><br><br>

      -> 먼저 다음과 같이 자주 사용하는 고정값은 매크로로 정의한다.<br>
      코드에서 3과 4를 그대로 사용하면 3과 4가 계속 나올 때마다 이 숫자는 무엇을 뜻하는지 한 번 더 생각해야 한다.<br>
      하지만 PIXEL_SIZE, PIXEL_ALIGN과 같이 이름을 정해주면 의미가 명확해지므로 코드가 읽기 쉬워진다.
      <blockquote>
        PIXEL_SIZE: 픽셀 한 개의 크기이다. 24비트 비트맵은 파랑(B), 초록(G), 빨강(R)을 1바이트씩 저장하므로 3바이트이다.<br>
        PIXEL_ALIGN: 픽셀 데이터의 가로 한 줄에서 남는 공간(padding)을 구하기 위한 정렬값이다(비트맵 포맷은 픽셀 데이터의 가로 한 줄을 저장할 때 4의 배수 크기로 저장합니다).
      </blockquote>

      -> 이제 main 함수에서 비트맵 파일 포인터, 출력 결과를 저장할 텍스트 파일 포인터, 비트맵 파일 헤더 구조체 변수, 비트맵 정보 헤더 구조체 변수를 선언한다.<br>
      그리고 픽셀 데이터를 읽기 위한 포인터, 픽셀 데이터 크기, 비트맵 이미지의 가로와 세로 크기, 픽셀 데이터의 가로 크기가 4의 배수가 아닐 때 남는 공간을 저장할 변수를 선언한다.<br>
      <img src="images/c/비트맵 main함수.png" width="50%"><br><br>

      -> 각 픽셀을 표현할 ASCII 문자를 배열로 만든다. 비트맵 이미지에서 픽셀의 RGB 색상값이 모두 0이면 검정색이고, 모두 255이면 흰색이다.<br>
      즉, 값이 작을수록 어두워지고 값이 클수록 밝아진다. 따라서 배열의 낮은 인덱스에는 획수가 많은 문자를 배치하고 높은 인덱스에는 획수가 적은 문자를 배치한다.<br>
      그리고 가장 큰 인덱스에는 공백 문자를 넣는다.<br>
      <img src="images/c/비트맵 배열.png" width="50%"><br><br>

      -> fopen 함수로 비트맵 파일을 바이너리 모드(rb)로 연 뒤 fread 함수로 비트맵 파일 헤더를 읽는다.<br>
      그다음에 비트맵 파일이 맞는지 확인하기 위해 bfType의 값이 'MB'가 맞는지 확인한다(2바이트 크기의 'BM'을 리틀 엔디언 방식으로 읽었으므로 'B'와 'M'이 뒤집혀서 'MB'가 된다).<br>
      만약 이 값이 맞지 않으면 비트맵 파일이 아니다.<br>
      <img src="images/c/비트맵 파일인지 검사하기.png" width="50%"><br><br>

      -> 이번에는 비트맵 정보 헤더를 읽는다. 비트맵 정보 헤더는 비트맵 파일 헤더 바로 뒤에 있으므로 파일 포인터를 이동시키지 않고 바로 fread 함수로 읽으면 된다.<br>
      비트맵 정보 헤더를 읽었으면 biBitCount의 값이 24인지 확인한다. 이번 예제에서는 24비트 비트맵만 처리할 것이므로 24가 아니면 파일 포인터를 닫고 프로그램을 종료한다.<br>
      <img src="images/c/비트맵 파일인지 검사하기2.png" width="50%"><br><br>

      -> 픽셀 데이터의 크기, 이미지의 가로, 세로 크기와 같이 자주 사용하는 정보는 변수에 따로 저장해놓는다.<br>
      매번 구조체에서 끌어다 써도 상관없지만 변수에 저장해놓고 사용하면 코드가 좀 더 간단해진다.<br>
      <img src="images/c/비트맵 파일 변수저장.png" width="50%"><br><br>

      ->이번에는 픽셀 데이터의 가로 공간이 저장될 때 남는 공간(padding)을 구해야 한다.<br>
      비트맵 포맷은 픽셀의 가로 한 줄을 저장할 때 4의 배수 크기로 저장하는데 만약 가로 한 줄의 크기가 4의 배수가 아니라면 남는 공간은 0으로 채워서 저장한다.<br>
      따라서 픽셀 데이터를 읽기 위해서는 남는 공간을 알고 있어야 한다.<br><br>

      -> 이런 방식을 사용하는 이유는 CPU가 데이터를 처리할 때 4바이트 크기가 효율적이기 때문이다.<br>
      예를 들어 3, 7, 11처럼 4로 나누어 떨어지지 않는 크기보다는 4, 8, 12처럼 4로 나누어 떨어지는 크기가 효율적이다.<br>
      데이터 크기를 4의 배수로 맞추고 0을 채워서 저장 공간이 좀 늘더라도 성능을 위해 이렇게 만들어져 있다.<br><br>

      -> 남는 공간을 구하기 전에 먼저 나머지를 구해야 되는데 계산식은 (가로 크기 * PIXEL_SIZE) % PIXEL_ALIGN이 된다.<br>
      예를 들어 가로 크기가 27일 때 나머지를 구하면 다음과 같다.<br>
      <img src="images/c/비트맵 나머지 구하기.png" width="50%"><br><br>
      <img src="images/c/비트맵 나머지 구하기2.png" width="50%"><br><br>

      -> 비트맵 파일 중에 픽셀 데이터의 크기 size가 0인 경우가 있다. 이때는 이미지의 가로 크기에 픽셀 크기를 곱한 뒤 남는 공간을 더해주면 완전한 가로 한 줄의 크기를 구할 수 있다.<br>
      그리고 여기에 이미지의 세로 크기를 곱해주면 픽셀 데이터의 크기를 구할 수 있다.<br>
      <img src="images/c/픽셀 데이터의 크기 size.png" width="50%"><br><br>

      -> 이제 비트맵 이미지의 픽셀 데이터를 읽는다. 24비트 비트맵 파일에서는 비트맵 정보 헤더 바로 다음에 픽셀 데이터가 있어서 바로 fread 함수로 읽어도 된다.<br>
      하지만 여기서는 bfOffBits 값을 활용하여 파일 포인터를 픽셀 데이터의 시작 위치로 이동시켰다.<br>
      <img src="images/c/비트맵 파일 포인터 이동.png" width="50%"><br><br>

      ->결과 출력용 텍스트 파일을 쓰기 모드(w)로 연다. 변환된 ASCII 문자를 콘솔(명령 프롬프트)에 바로 출력해도 되지만, 여기서는 파일에 저장한다.<br>
      만약 파일 열기에 실패하면 픽셀 데이터를 저장한 동적 메모리를 해제하고 프로그램을 종료한다.<br>
      <img src="images/c/비트맵 결과 출력.png" width="50%"><br><br>

      -> 픽셀 데이터를 ASCII문자로 변환<br>
      <img src="images/c/픽셀 데이터를 ASCII문자로 변환.png" width="50%"><br><br>
      -> &image[index]와 같이 배열(포인터)에 인덱스를 지정하여 현재 픽셀에 접근한 뒤 앞에 &를 붙여서 현재 픽셀의 메모리 주소를 구한다.<br>
      그리고 RGBTRIPLE 구조체로 선언한 포인터에 저장해준다. 이렇게 하면 RGBTRIPLE 구조체를 이용하여 각 픽셀의 빨강, 초록, 파랑(RGB) 값을 손쉽게 가져올 수 있다.<br><br>

      -> 비트맵 전체 소스코드<br>
      <img src="images/c/비트맵 전체 소스코드.png" width="50%"><br><br>
    </p>
    <br>
    <hr><br>

    <p>
      <h3>82.0 실전예제: 파일 아카이브 구현하기</h3>
      파일 아카이브는 파일 안에 파일을 보관하는 방식을 뜻한다.<br>
      // 대표적인 파일 아카이브 포맷<br>
      <blockquote>
        -> 압축 파일: zip, rar 등의 압축 포맷은 파일 안에 다른 파일을 압축하여 보관한다.<br><br>

        -> 테이프 아카이브 파일: tar는 유닉스/리눅스 명령인데 여러 파일을 파일 하나로 묶어준다. 단, 압축은 하지 않는다.<br>
        오래 전 자기 테이프를 쓰던 시절부터 있던 포맷이라 테이프 아카이브(tape archive)라 부른다.<br><br>

        -> 게임 데이터 파일: 파일 아카이브 포맷은 게임에서 주로 사용다.<br>
        게임은 텍스처(그림 파일), 3D 모델, 사운드 파일, 애니메이션 파일, 각종 수치 데이터 등으로 이루어져 있는데 파일 개수가 보통 몇 백 개에서 많게는 수십만 개에 이르기도 한다.<br>
        이렇게 많은 파일을 운영체제에 그대로 설치해서 게임을 실행하면 성능이 잘 나오지 않는다.<br>
        왜냐하면 운영체제에서 파일을 열고, 읽는 작업은 생각보다 부하가 크기 때문이다.<br>
        따라서 수많은 파일을 하나로 묶어서 아카이브 파일로 만들면 파일을 여는 동작은 한 번만 하면 되고, 이후부터는 파일 포인터를 이동시키면서 읽기만 하면 되기 때문에 성능이 향상된다.<br>
        MPQ: Mo'PaQ의 약자이며 블리자드에서 만든 게임에서 사용되는 파일 아카이브 포맷이다.<br>
        최근에 나온 게임부터는 MPQ 포맷보다 유지보수, 성능, 확장성이 뛰어난 CASC(Content Addressable Storage Container) 포맷을 사용하고 있다.
      </blockquote>

      파일의 내용만 연달아서 저장하면 어떤 파일이 저장되어 있고, 어느 위치에 저장되어 있는지 알기가 힘들다. 따라서 아카이브 파일 안에는 필요한 정보를 함께 저장해야 한다.<br>
      여러 요구사항을 만족하기 위해서는 다양한 정보를 저장해야 하겠지만 필수적인 정보는 파일 이름, 파일 크기, 파일 데이터 위치입니다(구현 방식에 따라 달라질 수 있다).<br>
      그리고 아카이브 파일이 맞는지 확인하기 위한 매직 넘버와 파일 버전도 필요하다.<br>
      <img src="images/c/아카이브 파일의 구조.png" width="50%"><br><br>

      바이너리 형식으로 된 파일은 파일 구조가 조금이라도 바뀌면 사용이 힘들어진다. 왜냐하면 1바이트라도 어긋나면 완전히 다른 정보를 읽게 되기 때문이다.<br>
      그래서 보통 바이너리 형식으로 된 파일은 파일(포맷) 버전을 함께 저장하고, 파일 버전이 맞을 때만 처리하도록 구현한다.<br>
      특히 버전간 호환성을 유지하면서 바이너리 파일의 구조를 설계하는 것은 쉽지 않은 일이다.<br><br>

      // 아카이브 파일 구조체 작성하기<br>
      <img src="images/c/아카이브 파일의 구조체.png" width="50%"><br><br>

      // 아카이브 파일에서 첫 파일을 추가하는 과정<br>
      <img src="images/c/아카이브 파일에서 첫 파일을 추가하는 과정.png" width="50%"><br><br>
      <img src="images/c/아카이브 파일에 아카이브 헤더 저장.png" width="50%"><br><br>

      // 아카이브 파일에서 <u>연결리스트로</u> 파일 목록을 출력하는 과정<br>
      <img src="images/c/아카이브 파일에서 파일 목록을 출력하는 과정.png" width="50%"><br><br>
      <img src="images/c/아카이브 파일 목록을 연결리스트로 관리.png" width="50%"><br><br>
      <img src="images/c/아카이브 파일 정보읽기.png" width="50%"><br><br>

      // 전체코드<br>
      <img src="images/c/아카이브 전체 코드.png" width="50%"><br><br>

      // 파일 추출하기<br>
      <img src="images/c/아카이브 파일에서 파일을 추출하는 과정.png" width="50%"><br><br>
      <img src="images/c/아카이브 파일에서 파일을 추출하는 함수.png" width="50%"><br><br>
      <br>
      <hr><br>

      <h2>
        <hr>
        <hr>기능별로 파일 나누기</h2>
      <hr>
      <hr>
      <img src="images/c/기능별로 파일 나누기.png" width="50%"><br><br>
      <img src="images/c/파일 아카이브 프로그램의 헤더 파일 포함 관계.png" width="50%"><br><br>

    </p>

  </blockquote>

  <blockquote>
    <h2>
      <hr>
      <hr>3/2</h2>
    <hr>
    <hr>

    <p>
      <h3>83.0 실전 예제: JSON 파일 읽고 쓰기</h3>
      JSON은 객체(object)를 { } (중괄호)로 표현한다.<br><br>

      // JSON 파일 읽기<br>
      <img src="images/c/JSON 파일 읽기.png" width="50%"><br><br>

      // JSON에서 문자열 파싱하기<br>
      <img src="images/c/JSON에서 문자열 파싱하기.png" width="50%"><br><br>

      // JSON에서 문자열 배열 파싱하기<br>
      <img src="images/c/JSON에서 문자열 배열 파싱하기.png" width="50%"><br><br>

      // JSON에서 숫자 파싱하기<br>
      <img src="images/c/JSON에서 숫자 파싱하기.png" width="50%"><br><br>
    </p>

    <p>
      힘들어서 굉장히 대충 끝냈다. 80강부터는 실전예제라 다시한번 공부해보면 좋을듯 하다.<br>
    </p>

  </blockquote>
  <br>
  <hr>
  <hr>
  <hr>
  <hr>
  <hr>
  <hr>
  <hr>
  <hr>
  <hr>
  <hr><br>

  <blockquote>
    <h2>
      <hr>
      <hr>
      <<<<<<<3 /2 파이썬 시작>>>>>>>
    </h2>
    <hr>
    <hr>

    <p>
      <h3>Unit 1. IDLE에서 Hello, world! 출력해보기</h3>
      >>> print('Hello, world!')<br><br>

      // python의 에러<br>
      <img src="images/python/대화형 셸.png" width="50%"><br><br>
    </p>
    <br>
    <hr>
    <p>
      <h3>Unit 5. 숫자 계산하기</h3>
      파이썬에서는 숫자를 정수, 실수, 복소수로 구분한다.<br><br>
      //은 버림 나눗셈(floor division)이라고 부르며 나눗셈의 결과에서 소수점 이하는 버린다. 참고로 실수에 // 연산자를 사용하면 결과는 실수가 나오며 소수점 이하는 버린다.<br><br>
      파이썬에서는 거듭제곱도 쉽게 구할 수 있다. >>> 2 ** 10 #1024<br><br>
      int에 괄호를 붙이고 숫자 또는 계산식을 넣으면 정수가 된다.
      <blockquote>
        &sdot; int(숫자)<br>
        &sdot; int(계산식)<br>
        &sdot; int('문자열')
      </blockquote>
      객체의 자료형을 알아내려면 type(값)을 사용하면 된다. >>> type(10) #class 'int'<br><br>
      몫과 나머지를 함께 구하려면 divmod를 사용하면 된다. >>> divmod(5, 2) #(2, 1)<br>
      -> 파이썬에서 값을 괄호로 묶은 형태를 튜플(tuple)이라고 하며 값 여러 개를 모아서 표현할 때 사용한다.<br>
      <blockquote>
        >>> quotient, remainder = divmod(5, 2)<br>
        >>> print(quotient, remainder)<br>
        2 1
      </blockquote>
      <img src="images/python/2진수, 8진수, 16진수.png" width="50%"><br><br>

      float에 괄호를 붙이고 숫자 또는 계산식을 넣으면 실수가 된다.
      <blockquote>
        &sdot; float(숫자)<br>
        &sdot; float(계산식)<br>
        &sdot; float('문자열')
      </blockquote>

      복소수<br>
      <img src="images/python/복소수.png" width="50%"><br><br>
    </p>
    <br>
    <hr>
    <p>
      <h3>Unit 6. 변수와 입력 사용하기</h3>
      변수이름 = 값 #변수생성<br>
      두 변수의 값을 바꾸려면 다음과 같이 변수를 할당할 때 서로 자리를 바꿔주면 된다.<br><br>
      변수 삭제는 del을 사용한다.<br><br>
      값이 들어있지 않는 변수는 >>> x = None #None을 할당해준다<br><br>
      계산을 하다 보면 부호를 붙여야 하는 경우도 생긴다. 이때는 값이나 변수 앞에 양수, 음수 부호를 붙이면 된다.<br><br>

      input 함수는 사용자가 입력한 값을 가져오는 함수이다.
      <blockquote>
        >>> input()<br>
        Hello, world! (입력)<br>
        'Hello, world!'
      </blockquote>
      input 함수의 결과를 변수에 할당하기
      <blockquote>
        &sdot; 변수 = input()<br>
        &sdot; 변수 = input('문자열을 입력하세요')
      </blockquote>
      10 + 20의 결과가 30이 나오게 하려면 input에서 입력받은 문자열을 숫자(정수)로 만들어주어야 한다.<br>
      <blockquote>
        &sdot; 변수 = int(input())<br>
        &sdot; 변수 = int(input('문자열을 입력하세요'))
      </blockquote>
      input 한 번에 값을 여러 개 입력받기
      <blockquote>
        &sdot; 변수1, 변수2 = input().split()<br>
        &sdot; 변수1, 변수2 = input().split('기준문자열')<br>
        &sdot; 변수1, 변수2 = input('문자열').split()<br>
        &sdot; 변수1, 변수2 = input('문자열').split('기준문자열')
      </blockquote>
      -> input에 split()을 사용하면 입력받은 값을 공백을 기준으로 분리하여 변수에 차례대로 저장한다.<br>
      -> 공백대신 콤마(,)를 사용하여 분리하고 싶으면 split(,)처럼 기준 문자를 변경한다.<br><br>

      split의 결과를 매번 int로 변환해주려니 귀찮다. 이때는 map을 함께 사용하면 된다.<br>
      map에 int와 input().split()을 넣으면 split의 결과를 모두 int로 변환해준다(실수로 변환할 때는 int 대신 float를 넣는다.).
      <blockquote>
        &sdot; 변수1, 변수2 = map(int, input().split())<br>
        &sdot; 변수1, 변수2 = map(int, input().split('기준문자열'))<br>
        &sdot; 변수1, 변수2 = map(int, input('문자열').split())<br>
        &sdot; 변수1, 변수2 = map(int, input('문자열').split('기준문자열'))
      </blockquote>
    </p>
  </blockquote>
  <br>
  <hr><br>

  <blockquote>
    <h2>
      <hr>
      <hr>
      <<<<<<<3 /3>>>>>>>
    </h2>
    <hr>
    <hr>
    <p>
      <h3>Unit 7. 출력 방법 알아보기</h3>
      print에는 변수나 값 여러 개를 ,(콤마)로 구분하여 넣을 수 있다.<br>
      <blockquote>
        &sdot; print(값1, 값2, 값3)<br>
        &sdot; print(변수1, 변수2, 변수3)
      </blockquote>
      print에 변수나 값을 콤마로 구분해서 넣으면 각 값이 공백으로 띄워져서 한 줄로 출력된다.<br><br>

      print의 sep에 문자 또는 문자열을 지정해주면 값 사이에 다른 문자나 문자열이 들어간다.
      <blockquote>
        &sdot; print(값1, 값2, sep='문자 또는 문자열')<br>
        &sdot; print(변수1, 변수2, sep='문자 또는 문자열')
      </blockquote>
      # 제어문자<br>
      <img src="images/python/제어 문자.png" width="50%"><br><br>

      print를 여러 번 사용해서 print(1, 2, 3)처럼 한 줄에 여러 개의 값을 출력하려면 print의 end에 빈 문자열을 지정해주면 된다.
      <blockquote>
        &sdot; print(값, end='문자 또는 문자열')<br>
        &sdot; print(변수, end='문자 또는 문자열')
      </blockquote>
      <img src="images/python/print_multiple_end.png" width="50%"><br><br>
      만약 1 2 3 사이를 띄워주고 싶다면 end에 공백 한 칸을 지정하면 된다.<br><br>

      <br>
      <hr><br>
      # 파이썬 산술 연산자<br>
      <img src="images/python/파이썬 산술 연산자.png" width="50%"><br><br>
      <br>
      <hr><br>

      # Q & A<br>
      <img src="images/python/Q & A(1).png" width="50%"><br><br>
      <img src="images/python/Q & A(2).png" width="50%"><br><br>
      <img src="images/python/Q & A(3).png" width="50%"><br><br>
    </p>
    <br>
    <hr><br>

    <p>
      <h3>Unit 8. 불과 비교, 논리 연산자 알아보기</h3>
      <h4>불 연산자 사용하기</h4>
      is, is not도 같다, 다르다지만 ==, !=는 값 자체를 비교하고, is, is not은 객체(object)를 비교한다.<br>
      <blockquote>
        >>> 1 == 1.0<br>
        True<br>
        >>> 1 is 1.0<br>
        False<br>
        >>> 1 is not 1.0<br>
        True
      </blockquote>
      <img src="images/python/정수 객체와 실수 객체가 서로 다른 걸 확인하는 id 함수.png" width="50%"><br><br>

      <h4>논리 연산자 사용하기</h4>
      and, or, not 이 가능하다.<br><br>

      # 정수, 실수, 문자열을 bool로 만들기<br>
      <img src="images/python/정수, 실수, 문자열을 bool로 만들기.png" width="50%"><br><br>

      # 단락 평가<br>
      <img src="images/python/단락 평가.png" width="50%"><br><br>
    </p>
    <br>
    <hr><br>

    <p>
      <h3>Unit 9. 문자열 사용하기</h3>
      Hello, world!를 ' '(작은따옴표)로 묶어서 문자열로 만들수 있다. 문자열은 영문 문자열뿐만 아니라 한글 문자열도 사용할 수 있다.<br>
      작은따옴표로 묶는 방법 이외에도 " "(큰따옴표)로 묶는것이 가능하고, '''(작은따옴표 3개)로 묶거나 """(큰따옴표 3개)로 묶을 수도 있다.<br><br>

      여러 줄로 된 문자열(multiline string)을 사용하려면 '''(작은따옴표 3개)로 시작하고 Hello, world!를 입력한 다음에 엔터 키를 누르면 다음 줄로 이동하고,<br>
      이런 방식으로 문자열을 계속 입력하고 마지막 줄에서 '''로 닫은 뒤 엔터 키를 누르면 >>> 프롬프트로 돌아온다.<br><br>

      문자열 안에 작은따옴표나 큰따옴표를 포함하려면 규칙이 달라진다.<br>
      # 문자열 안에 '(작은따옴표)를 넣고 싶다면 문자열을 "(큰따옴표)로 묶어준다.<br>
      # 반대로 문자열 안에 "(큰따옴표)를 넣고 싶다면 문자열을 '(작은따옴표)로 묶어준다.<br>
      # 작은따옴표 안에 작은따옴표를 넣거나 큰따옴표 안에 큰따옴표를 넣을 수는 없다.<br>

      하지만 여러 줄로 된 문자열은 작은따옴표 안에 작은따옴표와 큰따옴표를 둘 다 넣을 수 있다.<br>
      <img src="images/python/string_multiple_quote.png" width="50%"><br><br>

      # 문자열에 따옴표를 포함하는 다른 방법<br>
      <img src="images/python/문자열에 따옴표를 포함하는 다른 방법.png" width="50%"><br><br>
    </p>
    <br>
    <hr><br>

    <p>
      <h3>Unit 10. 리스트와 튜플 사용하기</h3>
      <p>
        <h4>리스트 사용하기</h4>
        변수에 값을 저장할 때 [ ](대괄호)로 묶어주면 리스트가 되며 각 값은 ,(콤마)로 구분해 준다.
        <blockquote>
          &sdot; 리스트 = [값, 값, 값]
        </blockquote>
        <br>
        빈 리스트를 만들 때는 [ ]만 지정하거나 list를 사용하면 된다.
        <blockquote>
          &sdot; 리스트 = []<br>
          &sdot; 리스트 = list()
        </blockquote>
        <br>
        range는 연속된 숫자를 생성하는데 range에 10을 지정하면 0부터 9까지 숫자를 생성한다. 즉, 지정한 횟수 숫자는 생성되는 숫자에 포함되지 않는다.<br>
        <blockquote>
          &sdot; range(횟수)<br>
          &sdot; 리스트 = list(range(횟수))<br>
          &sdot; 리스트 = list(range(시작, 끝))
        </blockquote>
        <img src="images/python/list_range.png" width="50%"><br><br>

        range에 증가폭을 지정하면 해당 값만큼 증가하면서 숫자를 생성한다.
        <blockquote>
          &sdot; 리스트 = list(range(시작, 끝, 증가폭))
        </blockquote>
      </p>
      <br>
      <hr><br>

      <p>
        <h4>튜플 사용하기</h4>
        튜플은 리스트처럼 요소를 일렬로 저장하지만, 안에 저장된 요소를 변경, 추가, 삭제를 할 수 없다. 간단하게 읽기 전용 리스트라고 할 수 있다.<br>
        변수에 값을 저장할 때 ( )(괄호)로 묶어주면 튜플이 되며 각 값은 ,(콤마)로 구분해준다. 또는, 괄호로 묶지 않고 값만 콤마로 구분해도 튜플이 된다.
        <blockquote>
          &sdot; 튜플 = (값, 값, 값)<br>
          &sdot; 튜플 = 값, 값, 값<br>
        </blockquote>
        튜플을 만든 상태에서 요소를 변경하게 되면 에러가 발생하게 된다. 따라서 요소를 실수로 변경하는 상황을 방지할 수 있다.<br>
        반면 요소를 자주 변경해야 할 때는 리스트를 사용한다. 보통 실무에서는 요소를 변경하는 경우가 많기 때문에 튜플보다 리스트를 더 자주 사용하는 편이다.<br><br>

        요소가 한 개인 튜플을 만들 때는 ( )(괄호) 안에 값 한 개를 넣고 ,(콤마)를 붙인다. 또는, 괄호로 묶지 않고 값 한 개에 ,를 붙여도 된다.
        <blockquote>
          &sdot; 튜플 = (값, )<br>
          &sdot; 튜플 = 값,<br>
        </blockquote>
        값 한 개를 괄호로 묶으면 튜플이 아니라 그냥 값이 된다.<br><br>

        # range를 사용하여 튜플을 만드는 방법
        <blockquote>
          &sdot; 튜플 = tuple(range(횟수))
        </blockquote>
        <img src="images/python/tuple_range.png" width="50%"><br><br>
      </p>
      <br>
      <hr><br>

      <p>
        <h4>튜플을 리스트로 만들고 리스트를 튜플로 만들기</h4>
        tuple 안에 리스트를 넣으면 새 튜플이 생긴다.
        <blockquote>
          >>> a = [1, 2, 3]<br>
          >>> tuple(a)<br>
          (1, 2, 3)
        </blockquote>
        list 안에 튜플을 넣으면 새 리스트가 생성된다.
        <blockquote>
          >>> b = (4, 5, 6)<br>
          >>> list(b)<br>
          [4, 5, 6]
        </blockquote>
      </p>

    </p>
    <br>
    <hr><br>

    <p>
      <h3>Unit 11. 시퀀스 자료형 활용하기</h3>
      파이썬에서는 리스트, 튜플, range, 문자열처럼 값이 연속적으로 이어진 자료형을 시퀀스 자료형(sequence types)라고 부른다.<br>
      <img src="images/python/시퀀스 자료형.png" width="50%"><br><br>
      <br>
      <hr><br>

      <p>
        <h4>시퀀스 자료형의 공통 기능 사용하기</h4>
        시퀀스 자료형의 가장 큰 특징은 공통된 동작과 기능을 제공한다는 점이다.<br>
        따라서 시퀀스 자료형의 기본적인 사용 방법을 익혀 두면 나중에 어떠한 시퀀스 자료형을 접하게 되더라도 큰 어려움 없이 바로 사용할 수 있다.<br><br>

        시퀀스 자료형으로 만든 객체를 시퀀스 객체라고 하며, 시퀀스 객체에 들어있는 각 값을 요소(element)라고 부른다.<br><br>

        시퀀스 객체 안에 특정 값이 있는지 확인하는 방법
        <blockquote>
          &sdot; 값 in 시퀀스객체
        </blockquote>
        반대로 in 앞에 not을 붙이면 특정 값이 없는지 확인한다.
        <blockquote>
          &sdot; 값 not in 시퀀스객체
        </blockquote>

        시퀀스 객체는 + 연산자를 사용하여 객체를 서로 연결하여 새 객체를 만들 수 있다.
        <blockquote>
          &sdot; 시퀀스객체1 + 시퀀스객체2
        </blockquote>

        단, 시퀀스 자료형 중에서 range는 + 연산자로 객체를 연결할 수 없다.<br>
        이때는 range를 리스트 또는 튜플로 만들어서 연결하면 가능하다.
        <blockquote>
          >>> list(range(0, 10)) + list(range(10, 20))<br>
          [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]<br>
          >>> tuple(range(0, 10)) + tuple(range(10, 20))<br>
          (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19)
        </blockquote>

        문자열은 + 연산자로 여러 문자열을 연결할 수 있다.
        <blockquote>
          >>> 'Hello, ' + 'world!'<br>
          'Hello, world!'
        </blockquote>

        # 문자열에 숫자 연결하기<br>
        <img src="images/python/문자열에 숫자 연결하기.png" width="50%"><br><br>

        * 연산자는 시퀀스 객체를 특정 횟수만큼 반복하여 새 시퀀스 객체를 만든다. (0 또는 음수를 곱하면 빈 객체가 나오며 실수는 곱할 수 없다).
        <blockquote>
          >>> [0, 10, 20, 30] * 3<br>
          [0, 10, 20, 30, 0, 10, 20, 30, 0, 10, 20, 30]
        </blockquote>
        마찬가지로 range는 * 연산자를 사용하여 반복할 수 없고, 이때는 range를 리스트 또는 튜플로 만들어서 반복하면 된다.<br><br>

        문자열은 * 연산자를 사용하여 반복할 수 있다.
        <blockquote>
          >>> 'Hello, ' * 3<br>
          'Hello, Hello, Hello, '
        </blockquote>
      </p>

      <br>
      <hr><br>

      <p>
        <h4>시퀀스 객체의 요소 개수 구하기</h4>
        요소의 개수(길이)를 구할 때는 len 함수를 사용한다.
        <blockquote>
          &sdot; len(시퀀스객체)
        </blockquote>

        시퀀스 객체에 [ ](대괄호)를 붙이고 [ ] 안에 각 요소의 인덱스를 지정하면 해당 요소에 접근할 수 있다.
        <blockquote>
          &sdot; 시퀀스객체[인덱스]
        </blockquote>
        <img src="images/python/__getitem__ 메서드.png" width="50%"><br><br>

        음수 인덱스 지정하기
        <blockquote>
          >>> a = [38, 21, 53, 62, 19]<br>
          >>> a[-1] # 리스트의 뒤에서 첫 번째(인덱스 -1) 요소 출력<br>
          19<br>
          >>> a[-5] # 리스트의 뒤에서 다섯 번째(인덱스 -5) 요소 출력<br>
          38
        </blockquote>

        리스트를 만든 뒤 범위를 벗어난 인덱스에 접근하면 리스트의 인덱스가 범위를 벗어났다는 IndexError가 발생한다.<br><br>

        마지막 요소에 접근하기
        <blockquote>
          >>> a = [38, 21, 53, 62, 19]<br>
          >>> len(a) # 리스트의 길이를 구함<br>
          5<br>
          >>> a[len(a) - 1] # 마지막 요소(인덱스 4) 출력<br>
          19
        </blockquote>

        시퀀스 객체는 [ ]로 요소에 접근한 뒤 =로 값을 할당한다.
        <blockquote>
          &sdot; 시퀀스객체[인덱스] = 값
        </blockquote>

        시퀀스 자료형 중에서 튜플, range, 문자열은 읽기 전용이다. 따라서 튜플, range, 문자열의 [ ]에 인덱스를 지정한 뒤 값을 할당하면 에러가 발생한다.<br><br>

        요소 삭제는 다음과 같이 del 뒤에 삭제할 요소를 지정해주면 된다.
        <blockquote>
          &sdot; del 시퀀스객체[인덱스]<br><br>
          >>> a = [38, 21, 53, 62, 19]<br>
          >>> del a[2]<br>
          >>> a<br>
          [38, 21, 62, 19]
        </blockquote>

        마찬가지로 읽기 전용인 튜플, range, 문자열의 요소를 삭제할 순 없다.<br><br>
      </p>

      <br>
      <hr><br>

      <p>
        <h4>슬라이스 사용하기</h4>
        슬라이스(slice)는 무엇인가의 일부를 잘라낸다는 뜻인데, 시퀀스 슬라이스도 말 그대로 시퀀스 객체의 일부를 잘라낸다.
        <blockquote>
          &sdot; 시퀀스객체[시작인덱스:끝인덱스]<br><br>

          >>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]<br>
          >>> a[0:4] # 인덱스 0부터 3까지 잘라서 새 리스트를 만듦<br>
          [0, 10, 20, 30]
        </blockquote>

        끝 인덱스는 실제로 가져오려는 인덱스보다 1을 더 크게 지정해야 한다.<br><br>

        슬라이스는 a[4:-1]과 같이 음수를 인덱스로 지정할 수도 있다.
        <blockquote>
          >>> a[4:-1] # 인덱스 4부터 -2(뒤에서 2번쨰)까지 요소 5개를 가져옴<br>
          [40, 50, 60, 70, 80]
        </blockquote>

        슬라이스는 인덱스의 증가폭을 지정하여 범위 내에서 인덱스를 건너뛰며 요소를 가져올 수 있다.
        <blockquote>
          &sdot; 시퀀스객체[시작인덱스:끝인덱스:인덱스증가폭]
        </blockquote>

        리스트 a에서 a[:7]과 같이 시작 인덱스를 생략하면 리스트의 처음부터 끝 인덱스 - 1(인덱스 6)까지 가져온다.
        <blockquote>
          &sdot; 시퀀스객체[:끝인덱스]
        </blockquote>

        a[7:]과 같이 끝 인덱스를 생략하면 시작 인덱스(인덱스 7)부터 마지막 요소까지 가져온다.
        <blockquote>
          &sdot; 시퀀스객체[시작인덱스:]
        </blockquote>

        a[:]와 같이 시작 인덱스와 끝 인덱스를 둘다 생략하면 리스트 전체를 가져온다.
        <blockquote>
          &sdot; 시퀀스객체[:]
        </blockquote>

        # 튜플, range, 문자열에 슬라이스 사용하기<br><br>
        <img src="images/python/튜플에 슬라이스 사용하기.png" width="50%"><br><br>

        # slice 객체 사용하기<br>
        <img src="images/python/slice 객체 사용하기.png" width="50%"><br><br>

        시퀀스 객체는 슬라이스로 범위를 지정하여 여러 요소에 값을 할당할 수 있다.
        <blockquote>
          &sdot; 시퀀스객체[시작인덱스:끝인덱스] = 시퀀스객체<br><br>

          >>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]<br>
          >>> a[2:5] = ['a', 'b', 'c'] # 인덱스 2부터 4까지 값 할당<br>
          >>> a<br>
          [0, 10, 'a', 'b', 'c', 50, 60, 70, 80, 90]
        </blockquote>

        a[2:5] = ['a', 'b', 'c']는 슬라이스 범위와 할당할 리스트의 요소 개수를 정확히 맞추었지만, 사실 개수를 맞추지 않아도 상관없다.
        <blockquote>
          >>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]<br>
          >>> a[2:5] = ['a'] # 인덱스 2부터 4까지에 값 1개를 할당하여 요소의 개수가 줄어듦<br>
          >>> a<br>
          [0, 10, 'a', 50, 60, 70, 80, 90]
        </blockquote>

        반면 할당할 요소 개수가 많으면 그만큼 리스트의 요소 개수도 늘어난다.
        <blockquote>
          >>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]<br>
          >>> a[2:5] = ['a', 'b', 'c', 'd', 'e'] # 인덱스 2부터 4까지 값 5개를 할당하여 요소의 개수가 늘어남<br>
          >>> a<br>
          [0, 10, 'a', 'b', 'c', 'd', 'e', 50, 60, 70, 80, 90]
        </blockquote>

        인덱스 증가폭을 지정하여 인덱스를 건너뛰면서 할당
        <blockquote>
          &sdot; 시퀀스객체[시작인덱스:끝인덱스:인덱스증가폭] = 시퀀스객체<br><br>

          >>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]<br>
          >>> a[2:8:2] = ['a', 'b', 'c'] # 인덱스 2부터 2씩 증가시키면서 인덱스 7까지 값 할당<br>
          >>> a<br>
          [0, 10, 'a', 30, 'b', 50, 'c', 70, 80, 90]
        </blockquote>
        단, 인덱스 증가폭을 지정했을 때는 슬라이스 범위의 요소 개수와 할당할 요소 개수가 정확히 일치해야 한다.<br><br>

        튜플, range, 문자열은 슬라이스 범위를 지정하더라도 요소를 할당할 수 없다.<br><br>

        슬라이스 삭제는 다음과 같이 del 뒤에 삭제할 범위를 지정해주면 된다.
        <blockquote>
          &sdot; del 시퀀스객체[시작인덱스:끝인덱스]<br><br>

          >>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]<br>
          >>> del a[2:5] # 인덱스 2부터 4까지 요소를 삭제<br>
          >>> a<br>
          [0, 10, 50, 60, 70, 80, 90]
        </blockquote>


      </p>
    </p>
    # list, range, tuple 정리<br>
    <img src="images/python/list, range, tuple 정리.png" width="50%"><br><br>

    # 시퀀스 자료형의 공통 기능 정리<br>
    <img src="images/python/시퀀스 자료형의 공통 기능 정리.png" width="50%"><br><br>

    # 시퀀스 자료형의 슬라이스 정리<br>
    <img src="images/python/시퀀스 자료형의 슬라이스 정리.png" width="50%"><br><br>
    </p>
  </blockquote>
  <hr><br>

  <blockquote>
    <h2>
      <hr>
      <hr>
      <<<<<<3 /4>>>>>>
    </h2>
    <hr>
    <hr>
    <p>
      <h3>Unit 12. 딕셔너리 사용하기</h3>
      파이썬에서는 연관된 값을 묶어서 저장하는 용도로 딕셔너리라는 자료형을 제공한다.<br>
      <blockquote>
        lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
      </blockquote>
      즉, 사전(dictionary)에서 단어를 찾듯이 값을 가져올 수 있다고 하여 딕셔너리라고 부른다.<br>
      <br>
      <hr><br>

      <p>
        <h4>딕셔너리 만들기</h4>
        딕셔너리는 { }(중괄호) 안에 키: 값 형식으로 저장하며 각 키와 값은 ,(콤마)로 구분해 준다.
        <blockquote>
          &sdot; 딕셔너리 = {키1: 값1, 키2: 값2}
        </blockquote>

        딕셔너리를 만들 때 키 이름이 중복되면 가장 뒤에 있는 값만 사용한다.<br><br>

        딕셔너리의 키는 문자열뿐만 아니라 정수, 실수, 불도 사용할 수 있으며 자료형을 섞어서 사용해도 된다.<br>
        그리고 값에는 리스트, 딕셔너리 등을 포함하여 모든 자료형을 사용할 수 있다.<br>
        <blockquote>
          >> x = {100: 'hundred', False: 0, 3.5: [3.5, 3.5]}<br>
          >>> x<br>
          {100: 'hundred', False: 0, 3.5: [3.5, 3.5]}
        </blockquote>
        단, 키에는 리스트와 딕셔너리를 사용할 수 없다.<br><br>

        빈 딕셔너리를 만들 때는 { }만 지정하거나 dict를 사용하면 된다. 보통은 { }를 주로 사용한다.<br>
        <blockquote>
          &sdot; 딕셔너리 = {}<br>
          &sdot; 딕셔너리 = dict()
        </blockquote>

        dict는 다음과 같이 키와 값을 연결하거나, 리스트, 튜플, 딕셔너리로 딕셔너리를 만들 때 사용한다.<br>
        <blockquote>
          &sdot; 딕셔너리 = dict(키1=값1, 키2=값2)<br>
          &sdot; 딕셔너리 = dict(zip([키1, 키2], [값1, 값2]))<br>
          &sdot; 딕셔너리 = dict([(키1, 값1), (키2, 값2)])<br>
          &sdot; 딕셔너리 = dict({키1: 값1, 키2: 값2})
        </blockquote>

        # dict 사용법<br>
        <img src="images/python/dict 사용법.png" width="50%"><br><br>
      </p>
      <br>
      <hr><br>

      <p>
        <h4>딕셔너리의 키에 접근하고 값 할당하기</h4>
        딕셔너리의 키에 접근할 때는 딕셔너리 뒤에 [ ](대괄호)를 사용하며 [ ] 안에 키를 지정해주면 된다.
        <blockquote>
          &sdot; 딕셔너리[키]
        </blockquote>

        딕셔너리는 [ ]로 키에 접근한 뒤 값을 할당한다.
        <blockquote>
          &sdot; 딕셔너리[키] = 값
        </blockquote>

        딕셔너리는 없는 키에 값을 할당하면 해당 키가 추가되고 값이 할당된다.
        <blockquote>
          >>> lux['mana_regen'] = 3.28 &emsp;&emsp;&emsp;&emsp;# 키 'mana_regen'을 추가하고 값 3.28 할당<br>
          >>> lux<br>
          {'health': 2037, 'mana': 1184, 'melee': 550, 'armor': 18.72, 'mana_regen': 3.28}
        </blockquote>

        딕셔너리에서 키가 있는지 확인하고 싶다면 in 연산자를 사용하면 된다.
        <blockquote>
          &sdot; 키 in 딕셔너리
        </blockquote>
        # 딕셔너리는 해시 기법을 이용해서 데이터를 저장한다.<br>
        <img src="images/python/딕셔너리는 해시 기법을 이용해서 데이터를 저장한다.png" width="50%"><br><br>

        딕셔너리의 키 개수 구하기
        <blockquote>
          &sdot; len(딕셔너리)
        </blockquote>
      </p>
    </p>
    <hr><br>

    <p>
      <h3>Unit 13. if 조건문으로 특정 조건일 때 코드 실행하기</h3>
      <br>
      <hr><br>

      <p>
        <h4>if 조건문 사용하기</h4>
        if 조건문은 if에 조건식을 지정하고 :(콜론)을 붙이며 다음 줄에 실행할 코드가 온다. 이때 실행할 코드는 반드시 들여쓰기를 해야 한다.
        <blockquote>
          if 조건식:<br>
          &emsp;&emsp;코드
        </blockquote>

        if 조건문에 조건식만 작성하고 코드를 생략하는 방법
        <blockquote>
          if x == 10:<br>
          &emsp;&emsp;pass&emsp;&emsp;&emsp;&emsp; # TODO: x가 10일 때 처리가 필요함
        </blockquote>

        pass는 아무 일도 하지 않는 코드라서 의미가 없을 것 같지만 나중에 작성해야 할 코드를 표시할 때 사용할 수 있다.<br>
        즉, 다음과 같이 pass만 넣고 나중에 할 일은 주석으로 남겨놓는 방식이다.<br><br>

        <img src="images/python/TODO 사용법.png" width="50%"><br><br>
        <img src="images/python/if와 들여쓰기 칸 수.png" width="50%"><br><br>
      </p>
    </p>
    <br>
    <hr><br>

    <p>
      <h3>Unit 14. else를 사용하여 두 방향으로 분기하기</h3>
      <p>
        <h4>else 사용하기</h4>
        <blockquote>
          if 조건식:<br>
          &emsp;&emsp;코드1<br>
          else:<br>
          &emsp;&emsp;코드2
        </blockquote>

        # 변수에 값 할당을 if, else로 축약하기<br>
        <img src="images/python/변수에 값 할당을 if, else로 축약하기.png" width="50%"><br><br>

        # python에서 True, False로 취급하는 것들<br>
        <img src="images/python/python에서 True, False로 취급하는 것들.png" width="50%"><br><br>
      </p>
    </p>
    <br>
    <hr><br>

    <p>
      <h3>Unit 15. elif를 사용하여 여러 방향으로 분기하기</h3>
      <p>
        if 조건식:<br>
        &emsp;&emsp;코드1<br>
        elif 조건식:<br>
        &emsp;&emsp;코드2<br>
        else:<br>
        &emsp;&emsp;코드3
      </p>
    </p>
    <br>
    <hr><br>

    <p>
      <h3>Unit 16. for 반복문</h3>
      <p>
        <h4>for와 range 사용하기</h4>
        for 반복문은 range에 반복할 횟수를 지정하고 앞에 in과 변수를 입력한다.
        <blockquote>
          &sdot; for 변수 in range(횟수):<br>
          &emsp;&emsp;반복할 코드
        </blockquote>

        시작하는 숫자와 끝나는 숫자 지정하기, 증가폭 사용하기
        <blockquote>
          &sdot; for 변수 in range(시작, 끝):<br>
          &sdot; for 변수 in range(시작, 끝, 증가폭):
        </blockquote>

        숫자를 감소시키기
        <blockquote>
          &sdot; for 변수 in range(시작, 끝, -증가폭):<br>
          &sdot; for 변수 in reversed(range(횟수)):<br>
          &sdot; for 변수 in reversed(range(시작, 끝)):<br>
          &sdot; for 변수 in reversed(range(시작, 끝, 증가폭)):
        </blockquote>
        <img src="images/python/참고 반복문의 변수 i를 변경할 수 있을까.png" width="50%"><br><br>

      </p>
      <br>
      <hr><br>
      <p>
        <h4>시퀀스 객체로 반복하기</h4>
        for에 range 대신 리스트를 넣으면 리스트의 요소를 꺼내면서 반복한다.
        <blockquote>
          >>> a = [10, 20, 30, 40, 50]<br>
          >>> for i in a:<br>
          ...&emsp;&emsp; print(i)<br>
          ...&emsp;&emsp;<br>
          10<br>
          20<br>
          30<br>
          40<br>
          50
        </blockquote>

        튜플도 마찬가지로 튜플의 요소를 꺼내면서 반복한다.
        <blockquote>
          >>> fruits = ('apple', 'orange', 'grape')<br>
          >>> for fruit in fruits:<br>
          ...&emsp;&emsp;print(fruit)<br>
          ...&emsp;&emsp;<br>
          apple<br>
          orange<br>
          grape
        </blockquote>

        for에 문자열을 지정하면 문자를 하나씩 꺼내면서 반복한다.
        <blockquote>
          >>> for letter in 'Python':<br>
          ...&emsp;&emsp;print(letter, end=' ')<br>
          ...<br>
          P y t h o n
        </blockquote>
        -> 문자열 'Python'의 문자가 하나씩 분리되어 출력되었다. 여기서는 print에 end=' '을 지정했으므로 줄바꿈이 되지 않고, 각 문자가 공백으로 띄워져서 출력된다.<br><br>

        앞에서 배운 reversed를 활용하면 문자를 뒤집어서 출력할 수 있다.
        <blockquote>
          &sdot; reversed(시퀀스객체)<br><br>

          >>> for letter in reversed('Python'):<br>
          ...&emsp;&emsp;print(letter, end=' ')<br>
          ...&emsp;&emsp;<br>
          n o h t y P
        </blockquote>
      </p>
    </p>
    <br>
    <hr><br>

    <p>
      <h3>Unit 17. while 반복문</h3>
      <p>
        while 반복문은 조건식을 지정하고 끝에 :(콜론)을 붙인 뒤 다음 줄에 반복할 코드와 변화식을 넣는다. 초기식은 특별한 것이 없고 보통 변수에 값을 저장하는 코드이다.
        <blockquote>
          초기식<br>
          while 조건식:<br>
          &emsp;&emsp;반복할 코드<br>
          &emsp;&emsp;변화식
        </blockquote>

        <h4>반복 횟수가 정해지지 않은 경우</h4>
        # 난수 생성<br>
        파이썬에서 난수를 생성하려면 random 모듈이 필요하다. 모듈은 다음과 같이 import 키워드를 사용하여 가져올 수 있다.
        <blockquote>
          &sdot; import 모듈<br><br>

          import random&emsp;&emsp;&emsp;&emsp; # random 모듈을 가져옴
        </blockquote>

        random.random()으로 random 모듈의 random 함수를 호출한다.
        <blockquote>
          >>> random.random()<br>
          0.002383731799935007<br>
          >>> random.random()<br>
          0.3297914484498006<br>
          >>> random.random()<br>
          0.6923390064955324
        </blockquote>

        randint 함수는 난수를 생성할 범위를 지정하며, 범위에 지정한 숫자도 난수에 포함된다.
        <blockquote>
          &sdot; random.randint(a, b)
        </blockquote>

        <img src="images/python/while_random.png" width="50%"><br><br>
        <img src="images/python/random.choice.png" width="50%"><br><br>
      </p>
    </p>
  </blockquote>
  <br>
  <hr><br>

  <blockquote>
    <h2>
      <hr>
      <hr>
      <<<<<<3 /5>>>>>>
    </h2>
    <hr>
    <hr>
    <p>
      <h3>Unit 18. break, continue로 반복문 제어하기</h3>
      <img src="images/python/참고 반복문과 pass.png" width="50%"><br><br>
    </p>
    <br>
    <hr><br>

    <p>
      <h3>Unit 19. 계단식으로 별 출력하기</h3>
      <br>
      <hr><br>
      <p>
        <h4>중첩 루프 사용하기<h4>
            <img src="images/python/중첩 루프.png" width="50%"><br><br>
            <img src="images/python/중첩 루프 예시.png" width="50%"><br><br>
      </p>

      <p>
        <h4>산모양 별 출력하기</h4>
        <blockquote>
          h = int(input())<br>
          w = 2*h-1<br><br>
          for i in range(h):<br>
          &emsp;&emsp;for j in range(h+i+1):<br>
          &emsp;&emsp;&emsp;if h-i <= j <=h+i:<br>
            &emsp;&emsp;&emsp;&emsp;print('*', end='' )<br>
            &emsp;&emsp;&emsp;else:<br>
            &emsp;&emsp;&emsp;&emsp;print(' ', end = '')<br>
            &emsp;&emsp;print()
        </blockquote>
      </p>
      <br>
      <hr><br>

      <p>
        <h4>FizzBuzz</h4>
        <blockquote>
          for i in range(1,101):<br>
          &emsp;&emsp;if(i%3==0 and i%5==0):<br>
          &emsp;&emsp;&emsp;&emsp;print(' FizzBuzz', end=' ' )<br>
          &emsp;&emsp;elif(i%3==0):<br>
          &emsp;&emsp;&emsp;&emsp;print('Fizz', end = ' ')<br>
          &emsp;&emsp;elif(i%5==0):<br>
          &emsp;&emsp;&emsp;&emsp;print('Buzz', end = ' ')<br>
          &emsp;&emsp;else:<br>
          &emsp;&emsp;&emsp;&emsp;print(i, end = ' ')
        </blockquote>

        # 코드 골프 방식
        <blockquote>
          for i in range(1, 101):<br>
          &emsp;&emsp;print('Fizz' * (i % 3 == 0) + 'Buzz' * (i % 5 == 0) or i) <br>
        </blockquote>
      </p>

    </p>
  </blockquote>
  <hr>
  <blockquote>
    <h2>
      <hr>
      <hr>
      <<<<<<3 /11>>>>>>
    </h2>
    <hr>
    <hr><br>

    <p>
      <h3>Unit 21. 터틀 그래픽스로 그림 그리기</h3>

      <p>
        <h4>사각형 그리기</h4>
        >>> import turtle as t<br>
        >>> t.shape('turtle')<br><br>
        <img src="images/python/파이썬 터틀 그래픽스 창과 거북이.png" width="50%"><br><br>

        >>> t.forward(100) &emsp;&emsp;# 거북이를 100픽셀만큼 앞으로 이동<br>
        >>> t.right(90) &emsp;&emsp;# 거북이의 방향을 바꿈<br>
        >>> t.forward(100)<br>
        >>> t.right(90)<br>
        >>> t.forward(100)<br>
        >>> t.right(90)<br>
        >>> t.forward(100)<br><br>

        <img src="images/python/거북이로 사각형 그리기.png" width="50%"><br><br>

        <blockquote>
          &sdot; 앞으로 이동: forward, fd<br>
          &sdot; 뒤로 이동: backward, bk, back<br>
          &sdot; 왼쪽으로 회전: left, lt<br>
          &sdot; 오른쪽으로 회전: right, rt
        </blockquote>

        # for 반복문으로 사각형 그리기
        <blockquote>
          import turtle as t<br><br>

          t.shape('turtle')<br>
          for i in range(4): &emsp;&emsp;&emsp;&emsp;# 사각형이므로 4번 반복<br>
          &emsp;&emsp;t.forward(100)<br>
          &emsp;&emsp;t.right(90)
        </blockquote>

        # for 반복문으로 다각형 그리기
        <blockquote>
          import turtle as t<br><br>

          n = int(input()) &emsp;&emsp;&emsp;&emsp; # 사용자의 입력을 받음<br>
          t.shape('turtle')<br>
          for i in range(n):&emsp;&emsp;&emsp;&emsp; # n각형이므로 n번 반복<br>
          &emsp;&emsp;t.forward(100)<br>
          &emsp;&emsp;t.right(360 / n) &emsp;&emsp;&emsp;&emsp;# 360을 n으로 나누어서 외각을 구함
        </blockquote>

        <h4>다각형에 색칠하기</h4>
        <img src="images/python/다각형에 색칠하기.png" width="50%"><br><br>
        <img src="images/python/빨간색 육각형 그리기.png" width="50%"><br><br>

        # color에 색깔 지정하기<br>
        <img src="images/python/color에 색깔 지정하기.png" width="50%"><br><br>

        <h4>복잡한 도형 그리기</h4>
        # 원 그리기<br><br>

        >>> import turtle as t<br>
        >>> t.shape('turtle')<br>
        >>> t.circle(120)<br>&emsp;&emsp;&emsp;&emsp;# 반지름이 120인 원<br><br>

        # 원을 반복해서 그리기<br><br>

        import turtle as t<br><br>

        n = 60 &emsp;&emsp;&emsp;&emsp;# 원을 60번 그림<br>
        t.shape('turtle')<br>
        t.speed('fastest') &emsp;&emsp;&emsp;&emsp; # 거북이 속도를 가장 빠르게 설정<br>
        for i in range(n):<br>
        &emsp;&emsp; t.circle(120) &emsp;&emsp;&emsp;&emsp; # 반지름이 120인 원을 그림<br>
        &emsp;&emsp; t.right(360 / n) &emsp;&emsp;&emsp;&emsp; # 오른쪽으로 6도 회전<br><br>
        <img src="images/python/원을 반복해서 그리기.png" width="50%"><br><br>

        # 선으로 복잡한 무늬 그리기<br><br>

        import turtle as t<br><br>

        t.shape('turtle')<br>
        t.speed('fastest')&emsp;&emsp;&emsp;&emsp; # 거북이 속도를 가장 빠르게 설정<br>
        for i in range(300):&emsp;&emsp;&emsp;&emsp; # 300번 반복<br>
        &emsp;&emsp;t.forward(i) &emsp;&emsp;&emsp;&emsp;# i만큼 앞으로 이동. 반복할 때마다 선이 길어짐<br>
        &emsp;&emsp;t.right(91) &emsp;&emsp;&emsp;&emsp;# 오른쪽으로 91도 회전<br>
        <img src="images/python/선으로 복잡한 무늬 그리기.png" width="50%"><br><br>

        # 터틀 모양 설정하기<br>
        <img src="images/python/터틀 모양 설정하기.png" width="50%"><br><br>
      </p>
    </p>
    <hr><br>

    <p>
      <h3>Unit 22. 리스트와 튜플 응용하기</h3>
      파이썬의 리스트는 생각보다 기능이 많은데, 요소를 추가/삭제하거나, 정보를 조회하는 메서드(함수)도 제공한다.<br>
      특히 for 반복문과 결합하면 연속적이고 반복되는 값을 손쉽게 처리할 수 있다.
      <p>
        <h4>리스트 조작하기</h4>
        <h5>리스트 추가하기</h5>
        &sdot; append: 요소 하나를 추가
        <blockquote>
          a.append(500)<br>
          a.append([500, 600])&emsp;&emsp;# 리스트안에 리스트 추가
        </blockquote>

        &sdot; extend: 리스트를 연결하여 확장
        <blockquote>
          a.extend([500, 600])&emsp;&emsp;# 리스트안에 요소를 여러개 추가
        </blockquote>

        &sdot; insert: 특정 인덱스에 요소 추가<br>
        <blockquote>
          a.insert(2, 500)&emsp;&emsp;# insert(인덱스, 요소) : 리스트의 특정 인덱스에 요소 하나를 추가<br>
          a.insert(1, [500, 600])&emsp;&emsp;# 리스트의 특정 인덱스에 리스트를 추가<br><br>

          insert(0, 요소): 리스트의 맨 처음에 요소를 추가<br>
          insert(len(리스트), 요소): 리스트 끝에 요소를 추가
        </blockquote>
        &sdot; 리스트 중간에 요소 여러 개를 추가하고 싶다면
        <blockquote>
          >>> a = [10, 20, 30]<br>
          >>> a[1:1] = [500, 600]&emsp;&emsp;# 슬라이스에 요소 할당하기를 활용<br>
          >>> a<br>
          [10, 500, 600, 20, 30]
        </blockquote>
        <br>

        <h5>리스트에 요소 삭제하기</h5>

        &sdot; pop: 마지막 요소 또는 특정 인덱스의 요소를 삭제
        <blockquote>
          pop()은 리스트의 마지막 요소를 삭제한 뒤 삭제한 요소를 반환&emsp;&emsp;# a.pop()<br><br>
          pop(인덱스)는 해당 인덱스의 요소를 삭제한 뒤 삭제한 요소를 반환&emsp;&emsp;# a.pop(1)<br><br>
        </blockquote>

        &sdot; remove: 특정 값을 찾아서 삭제
        <blockquote>
          remove(값)은 리스트에서 특정 값을 찾아서 삭제&emsp;&emsp;# a.remove(20)<br><br>
        </blockquote>

        # 리스트로 스택과 큐 만들기<br>
        <img src="images/python/리스트로 스택과 큐 만들기.png" width="50%"><br><br>
        <br>

        <h5>리스트에서 특정 값의 인덱스 구하기</h5>

        index(값)은 리스트에서 특정 값의 가장 처음 찾은 인덱스를 구한다.&emsp;&emsp;# >>> a.index(20)<br><br>

        <h5>특정 값의 개수 구하기</h5>

        count(값)은 리스트에서 특정 값의 개수를 구한다.&emsp;&emsp;# a.count(20)<br><br>

        <h5>리스트의 순서를 뒤집기</h5>

        reverse()는 리스트에서 요소의 순서를 반대로 뒤집는다.&emsp;&emsp;# a.reverse())<br><br>

        <h5>리스트의 요소를 정렬하기</h5>

        sort() 또는 sort(reverse=False): 리스트의 값을 작은 순서대로 정렬(오름차순)<br>
        sort(reverse=True): 리스트의 값을 큰 순서대로 정렬(내림차순)<br><br>
        <img src="images/python/sort 메서드와 sorted 함수.png" width="50%"><br><br>

        <h5>리스트의 모든 요소를 삭제하기</h5>

        clear()는 리스트의 모든 요소를 삭제한다.&emsp;&emsp;# a.clear()<br>
        lear 대신 del a[:]와 같이 시작, 끝 인덱스를 생략하여 리스트의 모든 요소를 삭제할 수도 있다.&emsp;&emsp;# del a[:]<br><br>

        <h5>리스트를 슬라이스로 조작하기</h5>

        리스트는 메서드를 사용하지 않고, 슬라이스로 조작할 수도 있다.&emsp;&emsp;# a[len(a):] = [500]<br><br>

        # 리스트가 비어 있는지 확인하기<br>
        <img src="images/python/리스트가 비어 있는지 확인하기.png" width="50%"><br><br>

      </p>
      <br>

      <p>
        <h4>리스트의 할당과 복사 알아보기</h4>
        b = a와 같이 리스트를 다른 변수에 할당하면 리스트는 두 개가 될 것 같지만 실제로는 리스트가 한 개이다.<br>
        >>> a = [0, 0, 0, 0, 0]<br>
        >>> b = a<br>
        >>> a is b<br>
        True<br><br>

        리스트 a와 b를 완전히 두 개로 만들려면 copy 메서드로 모든 요소를 복사해야 한다.<br>
        >>> a = [0, 0, 0, 0, 0]<br>
        >>> b = a.copy()<br><br>
      </p>
      <br>

      <p>
        <h4>반복문으로 리스트의 요소를 모두 출력하기</h4>

        <h5>for 반복문으로 요소 출력하기</h5>
        <blockquote>
          for 변수 in 리스트:<br>
          &emsp;&emsp;반복할 코드
        </blockquote>

        <h5>인덱스와 요소를 함께 출력하기</h5>
        <blockquote>
          &sdot; for 인덱스, 요소 in enumerate(리스트):<br><br>

          >>> a = [38, 21, 53, 62, 19]<br>
          >>> for index, value in enumerate(a):<br>
          ...&emsp;&emsp;&emsp;&emsp;print(index, value)<br>
          ...<br>
          0 38<br>
          1 21<br>
          2 53<br>
          3 62<br>
          4 19<br>
        </blockquote>

        인덱스를 0부터 출력하는데 1부터 출력하고 싶을 때
        <blockquote>
          &sdot; for 인덱스, 요소 in enumerate(리스트, start=숫자):
        </blockquote>
      </p>

      <p>
        <h4>리스트의 가장 작은 수, 가장 큰 수, 합계 구하기</h4>

        min은 리스트에서 가장 작은 값을 구하고, max는 가장 큰 값을 구한다.
        <blockquote>
          >>> a = [38, 21, 53, 62, 19]<br>
          >>> min(a)<br>
          19<br>
          >>> max(a)<br>
          62
        </blockquote>

        파이썬에서는 합계를 구하는 sum 함수를 제공한다.
        <blockquote>
          >>> a = [10, 10, 10, 10, 10]<br>
          >>> sum(a)<br>
          50
        </blockquote>
      </p>
      <br>

      <p>
        <h4>리스트 표현식 사용하기</h4>

        파이썬의 리스트가 특이한 점은 리스트 안에 for 반복문과 if 조건문을 사용할 수 있다는 점이다.<br>
        이렇게 리스트 안에 식, for 반복문, if 조건문 등을 지정하여 리스트를 생성하는 것을 리스트 컴프리헨션(list comprehension)이라고 한다.<br><br>

        &sdot; [식 for 변수 in 리스트]<br>
        &sdot; list(식 for 변수 in 리스트)
        <blockquote>
          >>> a = [i for i in range(10)] # 0부터 9까지 숫자를 생성하여 리스트 생성<br>
          >>> a<br>
          [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br>
          >>> b = list(i for i in range(10)) # 0부터 9까지 숫자를 생성하여 리스트 생성<br>
          >>> b<br>
          [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        </blockquote>

        # 대괄호와 list() 리스트 표현식<br>
        <img src="images/python/대괄호와 list() 리스트 표현식.png" width="50%"><br><br>

        <h5>리스트 표현식에서 if 조건문 사용하기</h5>

        &sdot; [식 for 변수 in 리스트 if 조건식]<br>
        &sdot; list(식 for 변수 in 리스트 if 조건식)
        <blockquote>
          >>> a = [i for i in range(10) if i % 2 == 0] &emsp;&emsp;&emsp;&emsp; # 0~9 숫자 중 2의 배수인 숫자(짝수)로 리스트 생성<br>
          >>> a<br>
          [0, 2, 4, 6, 8]
        </blockquote>

        <h5>for 반복문과 if 조건문을 여러 번 사용하기</h5>

        a = [i * j for j in range(2, 10)<br>
        &emsp;&emsp;&emsp;&emsp; for i in range(1, 10)]<br>

        # 리스트 표현식에 for가 여러 개일 때 처리 순서<br>
        <img src="images/python/리스트 표현식에 for가 여러 개일 때 처리 순서.png" width="50%"><br><br>
      </p>
      <br>

      <p>
        <h4>리스트에 map 사용하기</h4>

        map은 리스트의 요소를 지정된 함수로 처리해주는 함수이다.
        <blockquote>
          &sdot; list(map(함수, 리스트))<br>
          &sdot; tuple(map(함수, 튜플))
        </blockquote>
      </p>
      <br>

      <p>
        <h4>튜플 응용하기</h4>

        튜플은 리스트와는 달리 내용을 변경할 수 없다(불변, immutable).<br>
        따라서 내용을 변경하는 append 같은 메서드는 사용할 수 없고, 요소의 정보를 구하는 메서드만 사용할 수 있다.<br><br>
      </p>

    </p>

  </blockquote>
  <br>
  <hr><br>
  <blockquote>
    <h2>
      <hr>
      <hr>
      <<<<<<3 /13>>>>>>
    </h2>
    <hr>
    <hr>

    <p>
      <h3>Unit 23. 2차원 리스트 사용하기</h3>


      <p>
        <h4>2차원 리스트</h4>
        2차원 리스트는 리스트 안에 리스트를 넣어서 만들 수 있으며 안쪽의 각 리스트는 ,(콤마)로 구분한다.
        <blockquote>
          &sdot;리스트 = [[값, 값], [값, 값], [값, 값]]<br><br>

          a = [[10, 20],<br>
          [30, 40],<br>
          [50, 60] ]<br>
        </blockquote>

        # 톱니형 리스트<br>
        <img src="images/python/톱니형 리스트.png" width="50%"><br><br>

        # 2차원 튜플<br>
        <img src="images/python/2차원 튜플.png" width="50%"><br><br>

        # 2차원 리스트를 사람이 알아보기 쉽게 출력하기<br>
        <img src="images/python/2차원 리스트를 사람이 알아보기 쉽게 출력하기.png" width="50%"><br><br>

        <h5>반복문으로 2차원 리스트의 요소를 모두 출력하기</h5>
        for 반복문을 한 번만 사용하기
        <blockquote>
          >>> a = [[10, 20], [30, 40], [50, 60]]<br>
          >>> for x, y in a: # 리스트의 가로 한 줄(안쪽 리스트)에서 요소 두 개를 꺼냄<br>
          ... &emsp;&emsp; &emsp;&emsp;print(x, y)<br>
          ...<br>
          10 20<br>
          30 40<br>
          50 60
        </blockquote>

        for 반복문을 두 번 사용하기
        <blockquote>
          a = [[10, 20], [30, 40], [50, 60]]<br><br>

          for i in a: # a에서 안쪽 리스트를 꺼냄<br>
          &emsp;&emsp;for j in i: # 안쪽 리스트에서 요소를 하나씩 꺼냄<br>
          &emsp;&emsp;&emsp;&emsp;print(j, end=' ')<br>
          &emsp;&emsp;&emsp;&emsp;print()
        </blockquote>
      </p>

      <p>
        <h4>반복문으로 리스트 만들기</h4>
        <h5>for 반복문으로 1차원 리스트 만들기</h5>
        a = [] # 빈 리스트 생성<br><br>

        for i in range(10):<br>
        &emsp;&emsp;a.append(0)&emsp;&emsp; # append로 요소 추가<br><br>

        print(a)<br><br>

        <h5>for 반복문으로 2차원 리스트 만들기</h5>
        a = [] # 빈 리스트 생성<br><br>

        for i in range(3):<br>
        &emsp;&emsp;line = [] # 안쪽 리스트로 사용할 빈 리스트 생성<br>
        &emsp;&emsp;for j in range(2):<br>
        &emsp;&emsp;&emsp;&emsp;line.append(0) # 안쪽 리스트에 0 추가<br>
        &emsp;&emsp;&emsp;&emsp;a.append(line) # 전체 리스트에 안쪽 리스트를 추가<br><br>

        print(a)<br><br>

        >>> [[0, 0], [0, 0], [0, 0]]<br><br>

        <h5>톱니형 리스트 만들기</h5>
        a = [3, 1, 3, 2, 5] # 가로 크기를 저장한 리스트<br>
        b = [] # 빈 리스트 생성<br><br>

        for i in a: # 가로 크기를 저장한 리스트로 반복<br>
        &emsp;&emsp;line = [] # 안쪽 리스트로 사용할 빈 리스트 생성<br>
        &emsp;&emsp;for j in range(i): # 리스트 a에 저장된 가로 크기만큼 반복<br>
        &emsp;&emsp;&emsp;&emsp;line.append(0)<br>
        &emsp;&emsp;b.append(line) # 리스트 b에 안쪽 리스트를 추가<br><br>

        print(b)<br><br>

        # sorted로 2차원 리스트 정렬하기<br>
        <img src="images/python/sorted로 2차원 리스트 정렬하기.png" width="50%"><br><br>

        # 2차원 이상의 다차원 리스트는 리스트를 완전히 복사하려면 copy 메서드 대신 copy 모듈의 deepcopy 함수를 사용해야 한다.<br>
        <img src="images/python/sorted로 2차원 리스트 정렬하기.png" width="50%"><br><br>
      </p>
    </p>
    <br>
    <hr><br>
    <p>
      <h3>Unit 24. 문자열 응용하기</h3>

      <p>
        <h4>문자열 바꾸기</h4>
        replace('바꿀문자열', '새문자열')은 문자열 안의 문자열을 다른 문자열로 바꾼다.<br>
        <blockquote>
          >>> 'Hello, world!'.replace('world', 'Python')<br>
          'Hello, Python!'
        </blockquote>

        만약 바뀐 결과를 유지하고 싶다면 문자열이 저장된 변수에 replace를 사용한 뒤 다시 변수에 할당해준다.
        <blockquote>
          >>> s = 'Hello, world!'<br>
          >>> s = s.replace('world!', 'Python')<br>
          >>> s<br>
          'Hello, Python'
        </blockquote>

        translate는 문자열 안의 문자를 다른 문자로 바꾼다.<br>
        str.maketrans('바꿀문자', '새문자')로 변환 테이블을 만든다. 그다음에 translate(테이블)을 사용하면 문자를 바꾼 뒤 결과를 반환한다.
        <blockquote>
          >>> table = str.maketrans('aeiou', '12345')<br>
          >>> 'apple'.translate(table)<br>
          '1ppl2'
        </blockquote>
        <hr>
        <h4>문자열 분리하기</h4>
        split()은 공백을 기준으로 문자열을 분리하여 리스트로 만든다. 지금까지 input으로 문자열을 입력받은 뒤 리스트로 만든 메서드가 바로 이 split이다.
        <blockquote>
          >>> 'apple pear grape pineapple orange'.split()<br>
          ['apple', 'pear', 'grape', 'pineapple', 'orange']
        </blockquote>
        <hr>
        <h4>구분자 문자열과 문자열 리스트 연결하기</h4>

        join(리스트)는 구분자 문자열과 문자열 리스트의 요소를 연결하여 문자열로 만든다. 다음은 공백 ' '에 join을 사용하여 각 문자열 사이에 공백이 들어가도록 만든다.
        <blockquote>
          >>> ' '.join(['apple', 'pear', 'grape', 'pineapple', 'orange'])<br>
          'apple pear grape pineapple orange'
        </blockquote>
        <hr>
        <h4>소문자를 대문자로 바꾸기</h4>

        upper()는 문자열의 문자를 모두 대문자로 바꾼다.
        <blockquote>
          >>> 'python'.upper()<br>
          'PYTHON'
        </blockquote>
        <hr>
        <h4>대문자를 소문자로 바꾸기</h4>

        lower()는 문자열의 문자를 모두 소문자로 바꾼다.
        <blockquote>
          >>> 'PYTHON'.lower()<br>
          'python'
        </blockquote>
        <hr>
        <h4>왼쪽 공백 삭제하기</h4>

        lstrip()은 문자열에서 왼쪽에 있는 연속된 모든 공백을 삭제한다.
        <blockquote>
          >>> ' Python '.lstrip()<br>
          'Python '
        </blockquote>
        <hr>
        <h4>오른쪽 공백 삭제하기</h4>

        rstrip()은 문자열에서 오른쪽에 있는 연속된 모든 공백을 삭제한다.
        <blockquote>
          >>> ' Python '.rstrip()<br>
          ' Python'
        </blockquote>
        <hr>
        <h4>양쪽 공백 삭제하기</h4>

        strip()은 문자열에서 양쪽에 있는 연속된 모든 공백을 삭제한다.
        <blockquote>
          >>> ' Python '.strip()
          'Python'
        </blockquote>
        <hr>
        <h4>왼쪽의 특정 문자 삭제하기</h4>

        lstrip('삭제할문자들')과 같이 삭제할 문자들을 문자열 형태로 넣어주면 문자열 왼쪽에 있는 해당 문자를 삭제한다.
        <blockquote>
          >>> ', python.'.lstrip(',.')<br>
          ' python.'
        </blockquote>
        <hr>
        <h4>오른쪽의 특정 문자 삭제하기</h4>

        rstrip('삭제할문자들')과 같이 삭제할 문자들을 문자열 형태로 넣어주면 문자열 오른쪽에 있는 해당 문자를 삭제한다.
        <blockquote>
          >>> ', python.'.rstrip(',.')<br>
          ', python'
        </blockquote>
        <hr>
        <h4>양쪽의 특정 문자 삭제하기</h4>

        strip('삭제할문자들')과 같이 삭제할 문자들을 문자열 형태로 넣어주면 문자열 양쪽에 있는 해당 문자를 삭제한다.
        <blockquote>
          >>> ', python.'.strip(',.')<br>
          ' python'
        </blockquote>

        # 구두점을 간단하게 삭제하기<br>
        <img src="images/python/구두점을 간단하게 삭제하기.png" width="50%"><br><br>
        <hr>
        <h4>문자열을 왼쪽 정렬하기</h4>

        ljust(길이)는 문자열을 지정된 길이로 만든 뒤 왼쪽으로 정렬하며 남는 공간을 공백으로 채운다.
        <blockquote>
          >>> 'python'.ljust(10)<br>
          'python '
        </blockquote>
        <hr>
        <h4>문자열을 오른쪽 정렬하기</h4>

        rjust(길이)는 문자열을 지정된 길이로 만든 뒤 오른쪽으로 정렬하며 남는 공간을 공백으로 채운다.
        <blockquote>
          >>> 'python'.rjust(10)<br>
          ' python'
        </blockquote>
        <hr>
        <h4>문자열을 가운데 정렬하기</h4>

        center(길이)는 문자열을 지정된 길이로 만든 뒤 가운데로 정렬하며 남는 공간을 공백으로 채운다.
        <blockquote>
          >>> 'python'.center(10)<br>
          ' python '
        </blockquote>

        만약 가운데로 정렬했을 때 전체 길이와 남는 공간이 모두 홀수가 된다면 왼쪽에 공백이 한 칸 더 들어갑니다.
        <blockquote>
          >>> 'python'.center(11)<br>
          ' python '
        </blockquote>
        <hr>
        <h4>메서드 체이닝</h4>

        이렇게 문자열 메서드는 처리한 결과를 반환하도록 만들어져 있다. 따라서 메서드를 계속 연결해서 호출하는 메서드 체이닝이 가능하다.<br>
        메서드 체이닝은 메서드를 줄줄이 연결한다고 해서 메서드 체이닝(method chaining)이라 부른다.
        <blockquote>
          >>> 'python'.rjust(10).upper()<br>
          ' PYTHON'
        </blockquote>

        문자열을 입력받을 때 자주 사용했던 input().split()도 input()이 반환한 문자열에 split을 호출하는 메서드 체이닝이다.<br>
        <hr>
        <h4>문자열 왼쪽에 0 채우기</h4>

        zfill(길이)는 지정된 길이에 맞춰서 문자열의 왼쪽에 0을 채운다.<br>
        <blockquote>
          >>> '35'.zfill(4) # 숫자 앞에 0을 채움<br>
          '0035'<br>
          >>> '3.5'.zfill(6) # 숫자 앞에 0을 채움<br>
          '0003.5'<br>
          >>> 'hello'.zfill(10) # 문자열 앞에 0을 채울 수도 있음<br>
          '00000hello'
        </blockquote>
        <hr>
        <h4>문자열 위치 찾기</h4>

        find('찾을문자열')은 문자열에서 특정 문자열을 찾아서 인덱스를 반환하고, 문자열이 없으면 -1을 반환한다.<br>
        find는 왼쪽에서부터 문자열을 찾는데, 같은 문자열이 여러 개일 경우 처음 찾은 문자열의 인덱스를 반환한다.
        <blockquote>
          >>> 'apple pineapple'.find('pl')<br>
          2<br>
          >>> 'apple pineapple'.find('xy')<br>
          -1
        </blockquote>
        <hr>
        <h4>오른쪽에서부터 문자열 위치 찾기</h4>

        rfind('찾을문자열')은 오른쪽에서부터 특정 문자열을 찾아서 인덱스를 반환하고, 문자열이 없으면 -1을 반환한다.<br>
        <blockquote>
          >>> 'apple pineapple'.rfind('pl')<br>
          12<br>
          >>> 'apple pineapple'.rfind('xy')<br>
          -1
        </blockquote>
        <hr>
        <h4>문자열 위치 찾기</h4>

        index('찾을문자열')은 왼쪽에서부터 특정 문자열을 찾아서 인덱스를 반환한다. 단, 문자열이 없으면 에러를 발생시킨다.<br>
        index도 같은 문자열이 여러 개일 경우 처음 찾은 문자열의 인덱스를 반환한다.
        <blockquote>
          >>> 'apple pineapple'.index('pl')<br>
          2
        </blockquote>
        <hr>
        <h4>오른쪽에서부터 문자열 위치 찾기</h4>

        rindex('찾을문자열')은 오른쪽에서부터 특정 문자열을 찾아서 인덱스를 반환한다.
        <blockquote>
          >>> 'apple pineapple'.rindex('pl')<br>
          12
        </blockquote>
        <hr>
        <h4>문자열 개수 세기</h4>

        count('문자열')은 현재 문자열에서 특정 문자열이 몇 번 나오는지 알아낸다. 여기서는 'pl'이 2번 나오므로 2가 반환된다.
        <blockquote>
          >>> 'apple pineapple'.count('pl')<br>
          2
        </blockquote>

      </p>
      <br>
      <p>
        <h4>서식 지정자로 문자열 넣기</h4>

        '%s' % '문자열'
        <blockquote>
          >>> 'I am %s.' % 'james'<br>
          'I am james.'
        </blockquote>
        <hr>

        <h4>서식 지정자로 문자열 정렬하기</h4>

        %길이s
        <blockquote>
          >>> '%10s' % 'python'<br>
          ' python'
        </blockquote>

        # 자릿수가 다른 숫자 출력하기<br>
        <img src="images/python/구두점을 간단하게 삭제하기.png" width="50%"><br><br>

        <h4>서식 지정자로 문자열 안에 값 여러 개 넣기</h4>

        %d %s' % (숫자, '문자열')
        <blockquote>
          >>> 'Today is %d %s.' % (3, 'April')<br>
          'Today is 3 April.'
        </blockquote>
        <hr>

        <h4> format 메서드 사용하기</h4>

        '{인덱스}'.format(값)
        <blockquote>
          >>> 'Hello, {0}'.format('world!')<br>
          'Hello, world!'<br>
          >>> 'Hello, {0}'.format(100)<br>
          'Hello, 100'
        </blockquote><br>

        format 메서드로 값을 여러 개 넣기
        <blockquote>
          >>> 'Hello, {0} {2} {1}'.format('Python', 'Script', 3.6)<br>
          'Hello, Python 3.6 Script'
        </blockquote>

        <hr>
        <h4>format 메서드에서 인덱스 대신 이름 지정하기</h4>
        <blockquote>
          >>> 'Hello, {language} {version}'.format(language='Python', version=3.6)<br>
          'Hello, Python 3.6'
        </blockquote>
      </p>
    </p>

    <img src="images/python/list 핵심정리.png" width="50%"><br><br>

  </blockquote>

  <blockquote>
    <h2>
      <hr>
      <hr>
      <<<<<<>>>>>>
    </h2>
    <hr>
    <hr>

    <p>
      <h3>Unit 25. 딕셔너리 응용하기</h3>

    </p>
  </blockquote>

  <blockquote>
    <h2>
      <hr>
      <hr>
      <<<<<<>>>>>>
    </h2>
    <hr>
    <hr>

    <p>
      <h3></h3>

    </p>
  </blockquote>

</body>

</html>
